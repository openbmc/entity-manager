{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1c5bf535_03e0794c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 71,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-04-16T21:25:02Z",
      "side": 1,
      "message": "This isn\u0027t really a representative test though?  an S8030 has PCIe and NVMe ports, so we\u0027d need to also include all possible hardware that those have.",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 71,
        "endChar": 69
      },
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b310670_b456f24a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 71,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-04-16T22:01:12Z",
      "side": 1,
      "message": "My small examples do not convey the full intent or possibilities to use the feature.\n\n\u003e an S8030 has PCIe and NVMe ports, so we\u0027d need to also include all possible hardware that those have.\n\nYes. I would assume all configurations for any PCIe hardware to be always present in the fw image, for an upstream configuration of that option. Since most servers support PCIe hardware to be used on them.\n\nI have not fully defined all the edge cases for the feature yet, since i would like to first align on the general direction.\n\nHaving choice in support of peripheral components would be a more advanced version of this feature, since there are different form factors for power supplies and such which can limit the hardware supported.",
      "parentUuid": "1c5bf535_03e0794c",
      "range": {
        "startLine": 71,
        "startChar": 0,
        "endLine": 71,
        "endChar": 69
      },
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa1488a5_36de25f7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-04-16T21:25:02Z",
      "side": 1,
      "message": "Overall, my aversion to this is a fundamental one:  OpenBMC should be building software that is open to addition by both the system manufacturer AND those looking to add new hardware peripheral support to an existing system.  This design goal is stated at the top of the readme: https://github.com/openbmc/entity-manager?tab\u003dreadme-ov-file#goals\n\nCreating private company compatible lists where companies will only allow certain hardware on certain systems defeats some of the spirit of the \"open\" portion of OpenBmc, and means that when new configurations are enabled, they\u0027re only enabled on a subset of platforms.  Our builds should be \"open\" to improvement by anyone, not just the folks that manufacture or contract the board.  FWIW, in this patchset we\u0027re modifying which things are compatible with Tyan motherboards (that are buyable retail).  Who\u0027s the authority that should decide that support list given it\u0027s a commercial board?\n\nYes, there are downstream forks (including those of my employer) where removing all the configs except for a \"supported\" subset makes sense for their release model.  That kind of model is trivial to implement downstream (or even upstream if you wanted) in a meta layer if that\u0027s your goal.  That doesn\u0027t mean that it makes sense for something like OpenBMC, which aims to support firmware in the open.\n\nYes, we could do a better job of making the EM code performant (I\u0027m pretty sure nobody has ever profiled it since it was ported from the python script) and ensuring that we prevent conflicts between real hardware before they happen.  I suspect the former is pretty trivially solvable by optimizing the daemon a little.  The later I suspect is solved by requiring a fru match on manufacturer.",
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99658040_88e69253",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-04-16T22:01:12Z",
      "side": 1,
      "message": "So you don\u0027t like the feature because of how it may be used?\n\nThe intent of the feature is to reduce the configurations present in a BMC fw image to those which can be supported by the hardware.\n\nIt is intended to be an upstream feature used in openbmc/openbmc.\n\nFor example to prevent sbp1 and yv4 baseboard configuration from being present in a  fw image for Tyan s8030.\n\n\u003e and means that when new configurations are enabled, they\u0027re only enabled on a subset of platforms\n\nThat is an interpretation of the feature but not the intent.\n\nThe usage of the feature in the upstream is subject to review. So if config for hardware A is not present on a firmware image for board B even though board B supports hardware A then that is a misconfiguration.\n\n## who decides which hardware is supported\n\n\u003e Who\u0027s the authority that should decide that support list given it\u0027s a commercial board?\n\nThat depends on who is maintaining that layer. Nothing changes in that regard.\n\nThey should configure the option properly to support all the hardware which can be used on that system.\n\nI see this as analogous to configuring the linux kernel. There is not much incentive to support less than what the board is capable of. \n\n## the intent\n\n**If the hardware applies to or can be used on a server system**, the configuration for that hardware **should be present** in the firmware image.\n\nIf the configuration **will never apply** to the hardware, that configuration **should not be present** in a firmware image for said hardware.",
      "parentUuid": "aa1488a5_36de25f7",
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7d84ff65_cc2d1f2f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-04-17T21:01:35Z",
      "side": 1,
      "message": "\u003e So you don\u0027t like the feature because of how it may be used?\n\nThis is an over simplification of the above.\n\n\n\u003e The intent of the feature is to reduce the configurations present in a BMC fw image to those which can be supported by the hardware.\n\nRight, that\u0027s what the probe statements are already intended to do.\n\n\u003eFor example to prevent sbp1 and yv4 baseboard configuration from being present in a fw image for Tyan s8030.\n\nWhy does the configuration being PRESENT cause an issue?  If the configuration is wrong and has a bad probe, obviously that\u0027s an issue, but the config existing takes up pretty minimal space (and if that\u0027s an issue, can be easily compressed further than we\u0027ve attempted).\n\n\u003e That depends on who is maintaining that layer. Nothing changes in that regard.\n\nThere\u0027s no meta layers in what you\u0027ve proposed.  What\u0027s changed is that we\u0027ve now allowed classes of hardware.\n\n\u003e If the configuration will never apply to the hardware, that configuration should not be present in a firmware image for said hardware.\n\nThe way you know what configuration applies to a given piece of hardware is the probe statement.  If those are wrong, we can fix those rather than invent another analog.\n\n\n\n\u003e If the hardware applies to or can be used on a server system\n\nThis is the part I don\u0027t really see handled or examples of.  The example you have is giving each tyan baseboard a compat flag, but how do we know which tyan baseboard we\u0027re on unless we read the fru?   (As is the intent of EM).\n\nif that\u0027s the extent of what you\u0027re trying to do, the Device tree tagging that HPe pushed I think solves that issue already?\n\n\nHow do you see this tagging working for non-baseboards?",
      "parentUuid": "99658040_88e69253",
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0cd02c6_cb840d74",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-04-17T21:54:40Z",
      "side": 1,
      "message": "## adding instead of removing things\n\n\u003e Why does the configuration being PRESENT cause an issue?\n\nIt violates the basic principle of firmware images being built by adding things to them instead of removing them.\n\nFor example when configuring a linux kernel, one enables drivers and features to make it support the hardware. \n\nThat ensures there will be no surprises and overhead from things which are not needed. The overhead being both size and cpu cycles.\n\nImagine installing a linux distro and then first having to de-bloat it to remove all the crap that is not needed.\n\nWhen developing configuration for a board, i often end up changing it at runtime, then restarting EM. That is why it\u0027s useful for me to have a meson option to turn off the caching that EM tries to do with the ```system.json```.\nOtherwise my changes will not apply.\n\nWhen EM is restarted then it often spends many seconds just going through all the configuration files for yv4, sbp1, ... . Which is just wasting time since they will never probe on my board ðŸ˜Š\n\n## hopeless idealism\n\n\u003e The way you know what configuration applies to a given piece of hardware is the probe statement. If those are wrong, we can fix those rather than invent another analog.\n\nIt does not help to have the configuration for something if the drivers are not installed. There is no way to drive the hardware and it will just crash.\n\nI would consider it harmful to have a configuration mismatch with EM / Linux Kernel. EM config in a firmware image should always be a subset of what was enabled in the kernel.\n\nHow do you enforce this currently?\n\n\u003e but how do we know which tyan baseboard we\u0027re on unless we read the fru? (As is the intent of EM).\n\nWhoever is building a firmware image (for one or multiple boards) should configure the EM to install the right configuration. By default, EM should install all configurations in case someone forgets or does not want to limit the support.\n\n\u003e How do you see this tagging working for non-baseboards?\n\nIf there is a known limitation (such as PSU form factor)\nor add-on cards only available for specific OEM, then based on that there can be different tags.\n\nFor starting out i would propose going with just ```psu```, for powersupplies but there will likely be people who want to split that up some more.\n\nFor NIC, there are some specs from OCP for their different form factors and tags can be written based on that.\n\nSo a more realistic setting for the option to suppport e.g. 4 tyan boards with a single firmware image would be ```tyan-s8030, tyan-s5549, tyan-s8040, tyan-s8047, psu-XY, nic-ocp-Z, pcie, nvme```\n\nKeep in mind i am no expert on any of these standards or component compatibility in general. The intent for this is to be developed over time by multiple people if there is community interest.\n\nIf there is no one configuring the option, it may be dropped after some time as a failed feature.\n\n\n\u003e if that\u0027s the extent of what you\u0027re trying to do, the Device tree tagging that HPe pushed I think solves that issue already?\n\nDo you have a link? Is it an EM feature? Or are you talking about kernel device trees?\n\nKeep in mind not everyone is trying to build firmware images to support the greatest number of devices. One goal of firmware is to be small which is at odds with trying to support everything.\n\nBased on a platform architecture and BMC architecture there is a rabbit hole of complexities such as A/B schema, size constraints, flash partitioning, ...  which can make it impossible to support a large number of devices.",
      "parentUuid": "7d84ff65_cc2d1f2f",
      "revId": "396f767cb74c6c99b35d3ec15845db49c5689308",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}