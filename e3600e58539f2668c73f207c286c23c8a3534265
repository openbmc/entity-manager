{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "84a1007e_660e3528",
        "filename": "include/fru_utils.hpp",
        "patchSetId": 6
      },
      "lineNbr": 138,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-08T19:36:35Z",
      "side": 1,
      "message": "can we just implement this as a simple switch?  std::visit seems like kind of overkill for this.  Also, what if we want to use offset reader AND Caching reader (which seems likely for something like tyan)  the global offset stuff probably deserves to be a primitive within FruReader, instead of a wrapper class?",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 138,
        "endChar": 51
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1985f92d_5ac84a59",
        "filename": "include/fru_utils.hpp",
        "patchSetId": 6
      },
      "lineNbr": 138,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-06-08T19:57:47Z",
      "side": 1,
      "message": "My aim was to have the parsing code be able to stack an offset reader on top of a caching reader so as to avoid double-caching or having to muck around with stateful modifications to an offset setting that\u0027d then need to be un-done before returning  and moving on to another format parser that didn\u0027t want the offset applied (so that the application of the offset would just be scoped to the format parser that wanted it, without affecting anything else).",
      "parentUuid": "84a1007e_660e3528",
      "range": {
        "startLine": 138,
        "startChar": 0,
        "endLine": 138,
        "endChar": 51
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "113c62ab_5dbb3301",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-08T19:36:35Z",
      "side": 1,
      "message": "We\u0027d normally use std::visit for this kind of thing, to avoid the case where someone adds a new variant type, but forgets to add a case statement here.  With that said, I\u0027d really like to see offset reader not be variant based, and just use a switch statement.  There\u0027s only one function we\u0027re switching on here, maybe there\u0027s a good reason for the variant I\u0027m not seeing?",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "119a1255_6a824cfe",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-06-08T19:57:47Z",
      "side": 1,
      "message": "I had initially approached this via inheritance, with CachingReader and OffsetReader inheriting from a common base class, but after a comment of yours on a previous iteration discouraging the use of inheritance (https://gerrit.openbmc.org/c/openbmc/entity-manager/+/51548/13/include/FruUtils.hpp#100\u003d) I rearranged it this way instead (though TBH it seems like it just ends up being kind of a manual reimplementation of something approximating inheritance anyway, I guess).",
      "parentUuid": "113c62ab_5dbb3301",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "651c196f_668037f4",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-15T18:37:07Z",
      "side": 1,
      "message": "Just reinventing inheritance with variant doesn\u0027t seem like it solves the problem of readability here.\n\nit\u0027d be good to get other maintainers opinions here.",
      "parentUuid": "119a1255_6a824cfe",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60311b0d_12e59787",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-06-15T20:27:38Z",
      "side": 1,
      "message": "Agreed -- looking back at your other comment though (the one linked above), I guess I wasn\u0027t really clear on what you were suggesting regarding a composition-based approach as an alternative.  Could elaborate on that or provide a rough pseudocode sketch of what you meant?",
      "parentUuid": "651c196f_668037f4",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0149894_370a6c64",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-19T18:03:39Z",
      "side": 1,
      "message": "Something like\n\nswitch (type):\ncase (backend1):\n   readFromBackend1();\n   break;\ncase (backend2):\n    readFromBackend2();\n    break;\n    \nthat makes it a lot more clear what the options are for any given option, and things like the cache layer don\u0027t end up as a differen type.",
      "parentUuid": "60311b0d_12e59787",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bb1b4bc_fd82516c",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-06-20T20:53:05Z",
      "side": 1,
      "message": "Sorry, still not quite grasping the broader picture I\u0027m afraid...would the different backends there be like caching vs. offset, or something else?  And would that just be switching based on some explicit type enum within the FRUReader::read() method?\n\nThe way I had it arranged with the inheritance approach the constructor signatures guaranteed that the only arrangements that could exist were a bare caching reader or one or more offset readers stacked on top of a caching reader, so while they were different (derived) types, they shared the same base type and there would always be exactly one caching layer.",
      "parentUuid": "f0149894_370a6c64",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68f738f6_2425f5a9",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-06-21T14:51:15Z",
      "side": 1,
      "message": "I guess from my perspective \"Caching reader\" and \"offset reader\" are two completely different classes of reader, and are transforms that should be applied ahead of calling the backend, and both could be called with no branches in the offset case (just init offset to zero in most cases) and caching reader could just be aware of the backends and call them directly.\n\nStill would like other maintainers opinion on this here.",
      "parentUuid": "2bb1b4bc_fd82516c",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2e40f2e6_c186e89b",
        "filename": "src/fru_utils.cpp",
        "patchSetId": 6
      },
      "lineNbr": 137,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-07-07T00:32:47Z",
      "side": 1,
      "message": "\u003e I guess from my perspective \"Caching reader\" and \"offset reader\" are two completely different classes of reader,\n\nAs in, should be entirely distinct, incompatible types?  A major part of my aim here was that they would be compatible so that you could transparently pass an offset reader to the regular IPMI format parsing code in order to handle cases like the Tyan format and have that code accept either without having to care which it was.  (Hence initially taking the inheritance-based approach so that it could just accept the base class that both the caching and offset readers derive from.)\n\n\u003e transforms that should be applied ahead of calling the backend\n\nStill a bit uncertain what exactly you\u0027re referring to as a \"backend\" here -- do you mean the underlying ReadBlockFunc I/O routine, i.e. `readFromEeprom()` or `readBlockData()`?  If so, I thought the existing implementations would satisfy that criterion (though in the offset case the immediate backend is in turn a caching reader).\n\n\u003e and caching reader could just be aware of the backends and call them directly\n\nSo the caching reader would have to be aware of what type of eeprom it was reading from and explicitly call different functions depending on that?  I\u0027m not sure I see the advantage over the ReadBlockFunc callback-based approach we\u0027ve already got...\n\n\u003e Still would like other maintainers opinion on this here.\n\nYeah...Jae, Vernon -- any thoughts?",
      "parentUuid": "68f738f6_2425f5a9",
      "range": {
        "startLine": 130,
        "startChar": 1,
        "endLine": 137,
        "endChar": 66
      },
      "revId": "e3600e58539f2668c73f207c286c23c8a3534265",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}