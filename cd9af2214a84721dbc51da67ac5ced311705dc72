{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ccad1ecb_15b8be04",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-04-26T22:46:52Z",
      "side": 1,
      "message": "Can you explain why would it read the same byte?",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac79a164_734e9edd",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1001717
      },
      "writtenOn": "2024-05-03T16:44:16Z",
      "side": 1,
      "message": "my assumption is that for an 8 bit EEPROM, the pointer will not be internally incremented since the next byte address doesn\u0027t exist.",
      "parentUuid": "ccad1ecb_15b8be04",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a010056d_b491f771",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-05-06T22:43:26Z",
      "side": 1,
      "message": "It was my assumption too that it was using the different behavior of internal address. But since now the reading address is incremented and sent explicitly, I am not sure that the comment is correct anymore and the code is working as intended.\nDo we know what read mode is used - current, random or sequential.\n\nWithout understanding how it is supposed to be reading the same data, it is hard to know what is the right test in line 223.",
      "parentUuid": "ac79a164_734e9edd",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c74f93a7_9276c5be",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1001303
      },
      "writtenOn": "2024-05-13T19:20:54Z",
      "side": 1,
      "message": "`i2c_smbus_read_byte_data(file, 0)` is read a single byte from location 0x00.  The equivalent command is `i2ctransfer w1 0x00 r1`.\n\nThat writes 0x00 to the internal address pointer, reads a byte and then increments the internal pointer.  For an 8 bit EEPROM we end up reading from 0x00 each time and the value doesn\u0027t change.\n\nIf it\u0027s a 16 bit EEPROM then the assumption is writing 0x00 to the address pointer actually only overwrites the more significant address byte.  The least significant byte is left alone.  That means when the internal pointer increments after each read then that value is not lost.\n\nIt should look something like this:\n```\ninternal pointer\n0x00 0x00 \u003c--- Starting location (iteration 0)\n0x00 0x00 \u003c--- Write 0x00 to address\n0x00 0x00 \u003c--- Read a single byte (from 0x0000)\n0x00 0x01 \u003c--- Increment internal pointer after read\n\n0x00 0x01 \u003c--- Starting location (iteration 1)\n0x00 0x01 \u003c--- Write 0x00 to address\n0x00 0x01 \u003c--- Read a single byte (from 0x0001)\n0x00 0x02 \u003c--- Increment internal pointer after read\n\n0x00 0x02 \u003c--- Starting location (iteration 2)\n0x00 0x02 \u003c--- Write 0x00 to address\n0x00 0x02 \u003c--- Read a single byte (from 0x0002)\n0x00 0x03 \u003c--- Increment internal pointer after read\n....\n```\n\nThe value should change because you\u0027re reading the overall header from the IPMI FRU spec.\n\nThis approach isn\u0027t perfect because there is not an obligation for writing a single byte to the address pointer of a 16 bit EEPROM to only overwrite the most significant byte.  It could zero out the second byte for example.  In that case you end up reading from location 0x0000 on each iteration and the EEPROM gets erroneously interpreted as 8 bit.",
      "parentUuid": "a010056d_b491f771",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "47b69480_a964b909",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-05-31T23:20:42Z",
      "side": 1,
      "message": "Thanks for detailed info. So the old code actually works as expected. It just not all 16bit EEPROM works this way.",
      "parentUuid": "c74f93a7_9276c5be",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3ac047a4_25660af7",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1001717
      },
      "writtenOn": "2024-06-26T13:07:48Z",
      "side": 1,
      "message": "Your explanation is spot on with activities in the i2c trace. Thanks for the elaborate explanation.",
      "parentUuid": "47b69480_a964b909",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64a454f6_3716ad7a",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-04-26T22:46:52Z",
      "side": 1,
      "message": "But this will fail if in a 16bit eeprom, the first two bytes can still have the same data. The original code checks for up to 8 bytes. I guess the assumption was it would be very rare for 16bit eeprom has same data in all 8 bytes.",
      "range": {
        "startLine": 223,
        "startChar": 4,
        "endLine": 223,
        "endChar": 23
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "53d422ff_57e9770e",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1001717
      },
      "writtenOn": "2024-05-03T16:44:16Z",
      "side": 1,
      "message": "I agree the first two bytes can still have the same data. I have pushed a new commit to read up to 8 bytes. I believe the intention of the original code was to check for up to 8 bytes - atleast according to the comment in the original code. However, the original code kept the byte address, to be read, as constant i.e. 0.",
      "parentUuid": "64a454f6_3716ad7a",
      "range": {
        "startLine": 223,
        "startChar": 4,
        "endLine": 223,
        "endChar": 23
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}