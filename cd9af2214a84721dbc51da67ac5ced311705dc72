{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ccad1ecb_15b8be04",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 216,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-04-26T22:46:52Z",
      "side": 1,
      "message": "Can you explain why would it read the same byte?",
      "range": {
        "startLine": 215,
        "startChar": 7,
        "endLine": 216,
        "endChar": 12
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "64a454f6_3716ad7a",
        "filename": "src/fru_device.cpp",
        "patchSetId": 3
      },
      "lineNbr": 223,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-04-26T22:46:52Z",
      "side": 1,
      "message": "But this will fail if in a 16bit eeprom, the first two bytes can still have the same data. The original code checks for up to 8 bytes. I guess the assumption was it would be very rare for 16bit eeprom has same data in all 8 bytes.",
      "range": {
        "startLine": 223,
        "startChar": 4,
        "endLine": 223,
        "endChar": 23
      },
      "revId": "cd9af2214a84721dbc51da67ac5ced311705dc72",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}