{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "e32b72aa_86884568",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1320,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-10-16T11:52:55Z",
      "side": 1,
      "message": "entity-manager has a power status monitor (see `src/entity_manager/power_status_monitor.cpp`), does it make sense to re-use that instead of fru-device duplicating that code?\n\nThen we can keep the bugs in one file and not have to fix them twice.",
      "revId": "4e431491689cc44d09582d2aa86dfc8158c5401e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d84f62d_af18a0e9",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1320,
      "author": {
        "id": 1001853
      },
      "writtenOn": "2025-10-21T15:44:41Z",
      "side": 1,
      "message": "I don\u0027t think so, at least not currently.\n\nThe comparisons are not equivalent. In `entity-manager`\u0027s power status monitor (`power_status_monitor.cpp`), the check is:\n\n```\n        powerStatusOn \u003d\n            std::get\u003cstd::string\u003e(findState-\u003esecond).ends_with(\"Running\");\n```\n\nThis means both `TransitioningToRunning` and `Running` are interpreted as power-on states. If we reuse this logic, it will result in double scans during each host power-on ‚Äî one when in `TransitioningToRunning` and another when in `Running` state.\n\nTherefore, it seems safer to keep this logic separate for now. \n\nAlso, see this commit: https://github.com/openbmc/entity-manager/commit/3b13fb4b7f6b3dee5db2966b444d61c11f84153a",
      "parentUuid": "e32b72aa_86884568",
      "revId": "4e431491689cc44d09582d2aa86dfc8158c5401e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79e26cea_307609a2",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1320,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-10-21T15:54:42Z",
      "side": 1,
      "message": "Thanks for explaining this nuance here and linking the patch üëç\n\n\n\u003e Therefore, it seems safer to keep this logic separate for now. \n\nIt\u0027s a small difference in handling. We can use the same power status monitor and store the complete value of `CurrentHostState` internally.\n\nThen provide 2 different methods to access them something like this:\n\n```\nbool isPowerOn() // currently used in EM\nbool isPowerOnComplete() // require exactly \"xyz.openbmc_project.State.Host.HostState.Running\"\n```",
      "parentUuid": "0d84f62d_af18a0e9",
      "revId": "4e431491689cc44d09582d2aa86dfc8158c5401e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d75a2115_d5a0c419",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1320,
      "author": {
        "id": 1001853
      },
      "writtenOn": "2025-10-23T17:20:11Z",
      "side": 1,
      "message": "This approach won\u0027t address the problem. The primary goal isn\u0027t just checking the power state, but triggering actions, such as rescans, when the power state transitions from one specific state to another. This requires callback support in the power status monitor. \n\nImplementing callbacks is more complex than the current solution and depends on the use cases. For example, do we need callbacks for every power state change, or only for specific transitions?\n\nThe power status monitor is currently used only by entity-manager. Reviewing the entity-manager code shows that it does not need to trigger actions on power state changes. It\u0027s also uncertain whether such functionality might be needed in the future.",
      "parentUuid": "79e26cea_307609a2",
      "revId": "4e431491689cc44d09582d2aa86dfc8158c5401e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3f20d00f_43af85b5",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 2
      },
      "lineNbr": 1320,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-10-23T17:34:53Z",
      "side": 1,
      "message": "\u003e For example, do we need callbacks for every power state change, or only for specific transitions?\n\nThe callback can filter/register for the transitions that it finds interesting.\n\n\u003e It\u0027s also uncertain whether such functionality might be needed in the future.\n\nThat\u0027s the point of reusable software modules / classes.\nBundling several things and exposing them in some sane way.\nTo avoid duplicating these implementation details all over the place.\nLike property names / object paths / storing the matches.\n\nAnyways i guess i will close my comment since i realize it\u0027s asking a lot (scope creep) to do all this rework for a simple bugfix.\n\nThanks for the detailed explanation.",
      "parentUuid": "d75a2115_d5a0c419",
      "revId": "4e431491689cc44d09582d2aa86dfc8158c5401e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}