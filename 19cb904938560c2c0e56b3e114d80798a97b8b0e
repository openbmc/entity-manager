{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "958a848f_9e03c271",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 9
      },
      "lineNbr": 0,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2024-10-31T21:45:23Z",
      "side": 1,
      "message": "It may make sense to add a \u0027TESTED:\u0027 section to the bottom of the commit message. \n\nIf I want to test this on my own machine, what\u0027s an example configuration I could use in entity-manager, and what should I look for to tell that it\u0027s working?\n\n(you can surround large chunks of copy/pasted data that would normally break git commit message formatting and result with \u0027\u0027\u0027 marks if needed)",
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3fedeafd_93018e9e",
        "filename": "src/overlay.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2024-11-15T08:29:29Z",
      "side": 1,
      "message": "where\u0027s the code removing stale symlinks?\n\n\nwhere\u0027s the check that the mux names and channel names are unique?\n\n\ndevice and bus numbers not in the device tree can be reused after a parent unbind and the order is not preserved.\n\nI did find code in FRU device with an inotify watch but it\u0027s not creating files or links so there\u0027s nothing to clean up.  that\u0027s the only other reference to \"/dev\" I found in a GitHub search of this repository (search pattern was `/dev[^i]/` ignoring a few false positives).\n\n\n`libudev` can at least report when devices are removed.  it supports filters on the monitor for example the subsystem (i2c).\nWe still need to remember what was created to remove them, or rebuild or validate the directory on reload.  \n\nudev would manage such symlinks if we told it what to create. libudev however it\u0027s purely reporting what\u0027s been decided by the udev rules from the kernel reporting netlink.\n\ninstead we\u0027d need entries in udev rules (which this project is mostly trying to avoid from my observations) but we might be able to create a program involved by a rule that replies with the desired symlink creation.   I don\u0027t know what it\u0027d take to have udev reprocess a device after it was matched to our inventory tree.   It can probably triggered with udevadm coldplug support.\nwhile it\u0027s possible probably complex.\n\nI\u0027d be ok with something that looked for the target removal and unlink the symlink and directory created and some uniquenes checking.   (is the name supposed to include something from the instance like plug location?)",
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41c87bc1_3c3e92c9",
        "filename": "src/overlay.cpp",
        "patchSetId": 9
      },
      "lineNbr": 145,
      "author": {
        "id": 1001538
      },
      "writtenOn": "2025-07-24T19:58:55Z",
      "side": 1,
      "message": "Checking for stale symlinks is in: https://gerrit.openbmc.org/c/openbmc/entity-manager/+/80430",
      "parentUuid": "3fedeafd_93018e9e",
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e78861dd_32d7baeb",
        "filename": "src/overlay.cpp",
        "patchSetId": 9
      },
      "lineNbr": 396,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-11-12T21:48:59Z",
      "side": 1,
      "message": "what is the purpose of this block? Try for 2nd time?",
      "range": {
        "startLine": 378,
        "startChar": 1,
        "endLine": 396,
        "endChar": 5
      },
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2adf5ce6_025b2374",
        "filename": "src/overlay.cpp",
        "patchSetId": 9
      },
      "lineNbr": 396,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-11-12T21:54:43Z",
      "side": 1,
      "message": "re-read the commit message a bit - looks like this is meant to retry after MUX is loaded and logic bus is available. I think we want make that more clear in the code either with some comments and/or function and variable names. \nAlso i would expect this to be an iterative process as we can have mux behind a mux.",
      "parentUuid": "e78861dd_32d7baeb",
      "range": {
        "startLine": 378,
        "startChar": 1,
        "endLine": 396,
        "endChar": 5
      },
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b353710b_6567b87f",
        "filename": "src/overlay.cpp",
        "patchSetId": 9
      },
      "lineNbr": 396,
      "author": {
        "id": 1001538
      },
      "writtenOn": "2025-07-24T19:58:55Z",
      "side": 1,
      "message": "There is an iterative process when there are nested muxes with the creation of a new DeviceConfig object that attempts to be bound if a mux is detected to be connected behind the mux whose logical buses were identified (see linkMux and loadOverlays functions)",
      "parentUuid": "2adf5ce6_025b2374",
      "range": {
        "startLine": 378,
        "startChar": 1,
        "endLine": 396,
        "endChar": 5
      },
      "revId": "19cb904938560c2c0e56b3e114d80798a97b8b0e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}