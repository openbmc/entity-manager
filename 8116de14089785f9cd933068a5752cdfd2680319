{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ef17cd11_9231a3cf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2024-03-05T07:32:29Z",
      "side": 1,
      "message": "If this is the reactor that is hardcoded to look at EM, why isn\u0027t it under openbmc? (I\u0027m sure there\u0027s a reason, I\u0027ve just been out of the loop)",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23b546ac_44a53858",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T21:44:08Z",
      "side": 1,
      "message": "Last I heard the EM-\u003emctpd reactor was going in dbus-sensors.  This is just the generic MCTPd",
      "parentUuid": "ef17cd11_9231a3cf",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e4ac5c52_b75a7a40",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 22,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-06T01:09:36Z",
      "side": 1,
      "message": "Right, `mctpd` is not OpenBMC-specific. Additionally, we don\u0027t want `mctpd`-specifics in Entity Manager. So the plan is for an intermediate reactor. The reactor is proposed for dbus-sensors:\n\n[Add mctpreactor for dynamic configuration of MCTP networks](https://gerrit.openbmc.org/c/openbmc/dbus-sensors/+/69111)",
      "parentUuid": "23b546ac_44a53858",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ee9b7f3_1c5b8997",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T15:51:24Z",
      "side": 1,
      "message": "This would go into the Type field.\n\nType: \"SmbusMCTPInterface\"\nType: \"SerialMCTPInterface\"",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac90027a_2b031430",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T16:05:40Z",
      "side": 1,
      "message": "I looked at more examples, and I\u0027m very confused.\n\nTo support a piece of mctp hardware, you should write an EM config file for it, and that single EM config should contain all information required to instantiate the device.  This interface seems to require an author write BOTH an MCTPInterface on their baseboard definition, AND and MCTPDevice definition in the EM file, and that they have to match.\nThe Micron drive example in later patches shows the issue with this approach, in that it requires mapping an MCTPInterface name to a baseboard with a specific name.  That micron device could show up on essentially any baseboard in EM with an M.2 slot.  It doesn\u0027t seem like adding MCTPInterface definitions to every baseboard with an M.2 slot is worthwhile or wise.",
      "parentUuid": "7ee9b7f3_1c5b8997",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "358d85f0_0d72f868",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-06T01:09:36Z",
      "side": 1,
      "message": "\u003e  It doesn\u0027t seem like adding MCTPInterface definitions to every baseboard with an M.2 slot is worthwhile or wise.\n\nIt\u0027s not required that we do, but the consequence is that you can\u0027t talk MCTP to that device in the current schema. The current implementation of the reactor only configures the device if it has both the configuration for the device and the interface it\u0027s connected through. It\u0027s not an error to not provide one or both pieces (unless you require the MCTP functionality).\n\nAnyway, see the conversation below for how we might be able to avoid coupling `MCTPInterface` and `MCTPDevice` in the configs.",
      "parentUuid": "ac90027a_2b031430",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d34aeb30_90260a36",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-14T16:39:31Z",
      "side": 1,
      "message": "\u003e \u003e  It doesn\u0027t seem like adding MCTPInterface definitions to every baseboard with an M.2 slot is worthwhile or wise.\n\u003e \n\u003e It\u0027s not required that we do, but the consequence is that you can\u0027t talk MCTP to that device in the current schema. The current implementation of the reactor only configures the device if it has both the configuration for the device and the interface it\u0027s connected through.\n\nBut.... that\u0027s something that\u0027s implemented, and can be changed?  I\u0027m not really following the above;  Is there a reason it REQUIRES both pieces of information?\n\n\u003e It\u0027s not an error to not provide one or both pieces (unless you require the MCTP functionality).\n\u003e \n\u003e Anyway, see the conversation below for how we might be able to avoid coupling `MCTPInterface` and `MCTPDevice` in the configs.",
      "parentUuid": "358d85f0_0d72f868",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f3f3d7cf_34ba3dc8",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-14T23:53:47Z",
      "side": 1,
      "message": "\u003e But.... that\u0027s something that\u0027s implemented, and can be changed? I\u0027m not really following the above; Is there a reason it REQUIRES both pieces of information?\n\nIt doesn\u0027t - at the end of my reply above I wrote:\n\n\u003e Anyway, see the conversation below for how we might be able to avoid coupling MCTPInterface and MCTPDevice in the configs.\n\nSo it was coupled in the original patch, but I made some alternative proposals that don\u0027t require both pieces of information. I\u0027m not sure how else to communicate that.\n\nI want to go ahead with the (`\"Type\": \"SMBusMCTPDevice\"`) alternative where it\u0027s not coupled, but I\u0027m looking to tie up the loose ends of the conversation before doing so.",
      "parentUuid": "d34aeb30_90260a36",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f62cc2ea_f0be5afe",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 16,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-26T04:00:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f3f3d7cf_34ba3dc8",
      "range": {
        "startLine": 10,
        "startChar": 17,
        "endLine": 16,
        "endChar": 48
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56ceb637_6210c81f",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-03-07T05:24:12Z",
      "side": 1,
      "message": "Are there other transport should be included here like pcie etc?",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "20dd13a1_cb78ebf7",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-07T05:26:58Z",
      "side": 1,
      "message": "Yeah, absolutely. However, I was planning to add them as required rather than up-front. They might imply other the presence of other properties and I didn\u0027t want to expose myself to specifying the schema for all of them.",
      "parentUuid": "56ceb637_6210c81f",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aed2dd4f_f7a6a15f",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2024-03-08T16:51:10Z",
      "side": 1,
      "message": "I am OK will adding more later",
      "parentUuid": "20dd13a1_cb78ebf7",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "972bc23e_e4c0e5f2",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 19,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-26T04:00:08Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "aed2dd4f_f7a6a15f",
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "acc15219_39f2ec0c",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T15:51:24Z",
      "side": 1,
      "message": "Kernel specific parameters don\u0027t go in EM.  As an example, if I handed you a GPU, with all the specs for what its interfaces supported, there\u0027d be no way to fill this out without knowing what BMC it was being loaded on.\n\nTherefore, this kind of information goes in the reactor app, not in an EM config.\n\nIn addition, including it here has a huge potential for conflicts.  What if two devices put mctp0 here?  Which one do we merge?",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7a7acb9c_05bc06b5",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-06T01:09:36Z",
      "side": 1,
      "message": "\u003e In addition, including it here has a huge potential for conflicts. What if two devices put mctp0 here? Which one do we merge?\n\nDoes your change in understanding in your comments on line 60 address your question?\n\n\u003e Therefore, this kind of information goes in the reactor app, not in an EM config.\n\nPerhaps there\u0027s an opportunity for that.\n\n\u003e  As an example, if I handed you a GPU, with all the specs for what its interfaces supported, there\u0027d be no way to fill this out without knowing what BMC it was being loaded on.\n\nWell, yes and no. For example, the kernel will name all I2C/SMBus MCTP interfaces as `mctpi2cX` where `X` is the bus index. So configs can specify `Interface: \"mctpi2c$bus\"` and mostly expect correct behaviour. However, it does get murky with interface renaming via udev. I\u0027m not aware of anyone doing that yet.\n\nThe reactor needs to know the interface name, as specifying this [is a requirement for invoking `SetupEndpoint`](https://github.com/CodeConstruct/mctp/blob/main/docs/mctpd.md#setupendpoint) on `mctpd`\u0027s `/xyz/openbmc_project/mctp` object via the `au.com.CodeConstruct.MCTP` interface. Further, it needs to know the transport backing the interface as we need to encode the address into the byte array required by the `hwaddr` parameter of `SetupEndpoint`.\n\nPerhaps a different approach is to specify the bus index and the transport type. For instance, we could specify this instead:\n\n```\n{\n    \"Address\": \"0x1d\",\n    \"Bus\": \"$bus\",\n    \"Transport\": \"SMBus\",\n    \"Type\": \"MCTPDevice\"\n}\n```\n\n\nFor example, using the `Bus` value of `14` the reactor can construct a sysfs path to map to a netdev interface name associated with the bus:\n\n```\n# ls /sys/bus/i2c/devices/i2c-14/net/\nmctpi2c14\n```\nor\n```\n# ( . /sys/bus/i2c/devices/i2c-14/net/*/uevent ; echo $INTERFACE )\nmctpi2c14\n```\n\nAccounting for your feedback on the `MCTPInterface` schema above, we could perhaps merge `Transport` into the `Type` value:\n\n```\n{\n    \"Address\": \"0x1d\"\n    \"Bus\": \"$bus\"\n    \"Type\": \"SMBusMCTPDevice\"\n}\n```\n\nPerhaps this would allow us to do away with `MCTPInterface` for now, but MCTP netdev interfaces do need explicit setup. Child busses of I2C muxes on detected cards for instance: The i2c-dev for each mux leg must be configured as its own MCTP netdev interface.",
      "parentUuid": "acc15219_39f2ec0c",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "61b4ff1e_d90efc0b",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-14T16:39:31Z",
      "side": 1,
      "message": "\u003e \u003e In addition, including it here has a huge potential for conflicts. What if two devices put mctp0 here? Which one do we merge?\n\u003e \n\u003e Does your change in understanding in your comments on line 60 address your question?\n\n\nI\u0027m assuming you meant 50?  It doesn\u0027t quite help, but it starts to add context.\n\n\u003e \n\u003e \u003e Therefore, this kind of information goes in the reactor app, not in an EM config.\n\u003e \n\u003e Perhaps there\u0027s an opportunity for that.\n\u003e \n\u003e \u003e  As an example, if I handed you a GPU, with all the specs for what its interfaces supported, there\u0027d be no way to fill this out without knowing what BMC it was being loaded on.\n\u003e \n\u003e Well, yes and no. For example, the kernel will name all I2C/SMBus MCTP interfaces as `mctpi2cX` where `X` is the bus index. So configs can specify `Interface: \"mctpi2c$bus\"` and mostly expect correct behaviour.\n\nIf the kernel defines a naming scheme, why do we need \"mctpi2c\" in the config file?  Just expose the bus number as the bus (Like I think we already do in the existing interface), and we\u0027re done.\n\nI think my above point still stands.  There\u0027s no physical/software property of the Card that specifies \"MCTPi2c\", so it doesn\u0027t belong in a config file.\n\n\u003e However, it does get murky with interface renaming via udev. I\u0027m not aware of anyone doing that yet.\n\u003e \n\u003e The reactor needs to know the interface name,\n\nCan it not go look it up based on the bus using sysfs?\n\n\u003e as specifying this [is a requirement for invoking `SetupEndpoint`](https://github.com/CodeConstruct/mctp/blob/main/docs/mctpd.md#setupendpoint) on `mctpd`\u0027s `/xyz/openbmc_project/mctp` object via the `au.com.CodeConstruct.MCTP` interface. \n\nRight, so just have the daemon assign them mctpi2c(1-N) as the devices detect?\n\n\u003eFurther, it needs to know the transport backing the interface as we need to encode the address into the byte array required by the `hwaddr` parameter of `SetupEndpoint`.\n\n\"Type\": \"SMBusMCTPDevice\"\n\nIt think would support that still?  SMBusMCTPDevice maps to the smbus type?\n\n\u003e \n\u003e Perhaps a different approach is to specify the bus index and the transport type. For instance, we could specify this instead:\n\u003e \n\u003e ```\n\u003e {\n\u003e     \"Address\": \"0x1d\",\n\u003e     \"Bus\": \"$bus\",\n\u003e     \"Transport\": \"SMBus\",\n\u003e     \"Type\": \"MCTPDevice\"\n\u003e }\n\u003e ```\n\n\nThe problem with the above is that defining say, a serial port would look like:\n\n {\n    \"ID\": // Something to identify the port\n    \"Transport\": \"Serial\",\n     \"Type\": \"MCTPDevice\"\n }\n \n and now Address and bus have to be optional in schema.  If we separate out SMBusMCTPDevice and SerialMCTPDevice, we can make the required properties for each interface actually required.\n\n\u003e \n\u003e \n\u003e For example, using the `Bus` value of `14` the reactor can construct a sysfs path to map to a netdev interface name associated with the bus:\n\u003e \n\u003e ```\n\u003e # ls /sys/bus/i2c/devices/i2c-14/net/\n\u003e mctpi2c14\n\u003e ```\n\u003e or\n\u003e ```\n\u003e # ( . /sys/bus/i2c/devices/i2c-14/net/*/uevent ; echo $INTERFACE )\n\u003e mctpi2c14\n\u003e ```\n\u003e \n\u003e Accounting for your feedback on the `MCTPInterface` schema above, we could perhaps merge `Transport` into the `Type` value:\n\u003e \n\u003e ```\n\u003e {\n\u003e     \"Address\": \"0x1d\"\n\u003e     \"Bus\": \"$bus\"\n\u003e     \"Type\": \"SMBusMCTPDevice\"\n\u003e }\n\u003e ```\n\u003e \n\u003e Perhaps this would allow us to do away with `MCTPInterface` for now, but MCTP netdev interfaces do need explicit setup. Child busses of I2C muxes on detected cards for instance: The i2c-dev for each mux leg must be configured as its own MCTP netdev interface.\n\nRight, but what I don\u0027t understand is why we can\u0027t do logic of:\n\nif (mctp device detected):\n   set up mctp lane on that bus\n   \nin the reactor.",
      "parentUuid": "7a7acb9c_05bc06b5",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fadbb0dd_2c5d7050",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-14T23:53:47Z",
      "side": 1,
      "message": "I\u0027m largely going to draw a line under this thread with consensus on the `\"Type\": \"SMBusMCTPDevice\"` approach from my alternatives above.\n\n\u003e why we can\u0027t do logic of:\n\u003e\n\u003e if (mctp device detected):\n\u003e set up mctp lane on that bus\n\u003e\n\u003e in the reactor.\n\nYes, we can do that. However it\u0027s still necessary to specify necessary additional details for the interface (\"mctp lane on that bus\"), such as the link MTU (separate from the device MTU), whether or not the BMC should consider itself the bus owner for the interface or act as a peripheral or a bridge, and the network in which the interface participates. They can\u0027t be inferred so I think they motivate an `MCTPInterface` config node or some equivalent. We can correlate this on the bus index (I2C) or device index (serial) to locate the appropriate interface config without specifying the kernel\u0027s interface name in the configs. I will make an new patchset that defines this approach.\n\nCurrently mctpd assumes it\u0027s the top-most bus owner and the bus owner for all interfaces, though Ampere have the motivation for the BMC to support peripheral cases.",
      "parentUuid": "61b4ff1e_d90efc0b",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "93e7e32d_ccb3ef50",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-26T04:00:08Z",
      "side": 1,
      "message": "Done.\n\nOne note though: I\u0027ve decided to switch the name of the schema to `MCTPI2CTarget`.\n\nSeveral motivations here:\n\n1. In v7 of the I2C spec \"master\" and \"slave\" are replaced by \"controller\" and \"target\" respectively. The updated language aligns with v7.\n\n2. The language more closely aligns with the hardware, as SMBus is largely a protocol built atop I2C\n\n3. The in-kernel implementation of DSP0237 refers to the capability as I2C rather than SMBus, so increase alignment there also.",
      "parentUuid": "fadbb0dd_2c5d7050",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "692015da_cbda18d9",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-04-03T16:46:20Z",
      "side": 1,
      "message": "\u003e I\u0027m largely going to draw a line under this thread with consensus on the `\"Type\": \"SMBusMCTPDevice\"` approach from my alternatives above.\n\u003e \n\u003e \u003e why we can\u0027t do logic of:\n\u003e \u003e\n\u003e \u003e if (mctp device detected):\n\u003e \u003e set up mctp lane on that bus\n\u003e \u003e\n\u003e \u003e in the reactor.\n\u003e \n\u003e Yes, we can do that. However it\u0027s still necessary to specify necessary additional details for the interface (\"mctp lane on that bus\"), such as the link MTU (separate from the device MTU), \n\nI\u0027m a little surprised that there isn\u0027t a default MTU that works for all systems.  Does the spec not say anything about how MTUs should work?  I would assume you request the device MTU with a small MTU size, and increase if the device supports a larger transmission unit?\n\n\u003e whether or not the BMC should consider itself the bus owner for the interface or act as a peripheral or a bridge, and the network in which the interface participates.\n\nThere was no mention of \"is BMC is a bus owner on this bus\" on the original patch.  That makes significantly more sense.  Is that something that can be infered from the device itself?  If the device isn\u0027t a bus owner, presumably the BMC has to be the bus owner?\n\n\u003e They can\u0027t be inferred so I think they motivate an `MCTPInterface` config node or some equivalent. We can correlate this on the bus index (I2C) or device index (serial) to locate the appropriate interface config without specifying the kernel\u0027s interface name in the configs. I will make an new patchset that defines this approach.\n\u003e \n\u003e Currently mctpd assumes it\u0027s the top-most bus owner and the bus owner for all interfaces, though Ampere have the motivation for the BMC to support peripheral cases.\n\nACK",
      "parentUuid": "fadbb0dd_2c5d7050",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bb25ebbc_333479ff",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-04-04T05:43:29Z",
      "side": 1,
      "message": "\u003e I\u0027m a little surprised that there isn\u0027t a default MTU that works for all systems.\n\nMCTP specifies a \"Baseline Transmission Unit\" (BTU, minimum MTU) of 64 bytes. All MCTP-compliant devices must support the BTU, and all MCTP control messages fit inside the BTU. That\u0027s necessary so we can perform path MTU discovery. However, the BTU causes a lot of overhead (NVMe-MI gives some experience here).\n\n\u003e Does the spec not say anything about how MTUs should work? I would assume you request the device MTU with a small MTU size, and increase if the device supports a larger transmission unit?\n\nIt says an awful lot about MTUs and path MTU discovery. It also says that configuring the MTU for a given message type on a given device is a problem left to the message-type protocol. See DSP0236 v1.3.1, Section 9.5.1 Path Transmission Unit Negotiation:\n\n\u003e The MCTP control protocol only specifies how to discover what the path transmission unit size is for the path between endpoints. The MCTP control protocol does not specify a generic mechanism for discovering what transmission unit sizes a particular endpoint supports for a given message type. Discovery and negotiation of transmission unit sizes for endpoints, if supported, is specified by the definition of the particular message type.",
      "parentUuid": "692015da_cbda18d9",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d89f218_83a176b2",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 39,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-04-05T02:58:00Z",
      "side": 1,
      "message": "\u003e It says an awful lot about MTUs and path MTU discovery. It also says that configuring the MTU for a given message type on a given device is a problem left to the message-type protocol.\n\nThat said, we could probably set the interface MTU to the maximum known for its underlying transport by default to remove it as an obvious constraint from the path MTU.",
      "parentUuid": "bb25ebbc_333479ff",
      "range": {
        "startLine": 39,
        "startChar": 0,
        "endLine": 39,
        "endChar": 79
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "342dcfc5_e19fd7be",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T15:51:24Z",
      "side": 1,
      "message": "How would this work in practice?  This seems like an interface that would just allow people to hardcode addresses/IDs for every possible device, and not have to support dynamic detection at all?  Why use EM then?",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3f979a2c_6222dbda",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-06T01:09:36Z",
      "side": 1,
      "message": "I think there\u0027s a middle ground. Using it for hot-pluggable devices is questionable. However, it could be used to provide deterministic addresses for devices on the BMC card or the main planar. Essentially, in the tree of the MCTP bus topology, things that are closer to the root (BMC) could exploit it. EM is used to dynamically detect all the cards including main planar. Encoding some platform policy in the main planar config file doesn\u0027t feel unreasonable to me. But as mentioned it\u0027s way more questionable to do something like that in the config for e.g. the Micron drive.",
      "parentUuid": "342dcfc5_e19fd7be",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "11949715_de442df6",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-14T16:39:31Z",
      "side": 1,
      "message": "\u003e I think there\u0027s a middle ground. Using it for hot-pluggable devices is questionable.\n\nI made no mention of hot plug (Plugging in a device while the system is on).  What I\u0027m worried about are devices that you didn\u0027t explicitly expect to be plugged in, which is really the whole point of entity-manager.  Devices that might:\n1. Have multiple devices that plug into the same port.\n2. Have multiple ports on multiple boards that accept the same class of device\n3. Have the same device that plugs into multiple baseboards (ie, a normal PCIe card).\n\n\u003e However, it could be used to provide deterministic addresses for devices on the BMC card or the main planar.\n\nWhat is a \"Deterministic address\"?  A physical card doesn\u0027t have a deterministic address, and attempting to put it into a config file doesn\u0027t make sense.  For things like dynamic-sensors in ipmi, we get semi-determinism by allocating lanes based on hashes, and only moving them in the case of collisions (which would have been non-deterministic anyway).  Could we do something similar here?\n\n\u003e Essentially, in the tree of the MCTP bus topology, things that are closer to the root (BMC) could exploit it. EM is used to dynamically detect all the cards including main planar. Encoding some platform policy in the main planar config file doesn\u0027t feel unreasonable to me.  But as mentioned it\u0027s way more questionable to do something like that in the config for e.g. the Micron drive.\n\nI\u0027m really not understanding what\u0027s being encoded in the main planar?",
      "parentUuid": "3f979a2c_6222dbda",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dba627e7_a6b16e61",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-03-14T23:53:47Z",
      "side": 1,
      "message": "I\u0027m going to back up a bit.\n\nIf you\u0027re going take issue with `StaticEndpointID` in this patch, can you unpack your reasons for giving a CR+1 to [Add mctp eids configuration for Yosemite 4](https://gerrit.openbmc.org/c/openbmc/entity-manager/+/66750)? `StaticEndpointID` in my patch `EndpointId` in Meta\u0027s patch. We can change the name back if that helps. Part of what I\u0027m trying to do in my patch is remove assumptions we have to make in the reactor implementation about the transport type based on the lack of metadata in that schema definition.\n\n\u003e What is a \"Deterministic address\"?\n\nBy address I mean EID, and by deterministic I mean one that can be derived from physical addressing properties of the MCTP-capable device. EM supports evaluation of an expression language in its configuration values. A value for `StaticEndpointID` (an address) can be derived from e.g. the bus index and physical address for the device, _if that\u0027s desired and appropriate for the board/device config_.\n\n`StaticEndpointID` is _optional_, and it must not be provided in configs where it\u0027s not appropriate.\n\n\u003e I\u0027m really not understanding what\u0027s being encoded in the main planar?\n\nThe use of `StaticEndpointID` in the main planar _config_, for example for MCTP devices that are integrated into the main planar and are not pluggable.\n\nAssigning a static EID to a device excludes it from the pool of dynamic EIDs that are allocated out on demand. Addressing will remain coherent. Use of a static (not dynamic) constant (not derived) value for `StaticEndpointID` in the config of a pluggable device is inappropriate use `StaticEndpointID`.",
      "parentUuid": "11949715_de442df6",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e2be9cc1_e77056a4",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-04-03T16:46:20Z",
      "side": 1,
      "message": "\u003e If you\u0027re going take issue with StaticEndpointID\n\nEndpointID is the endpoint of the MCTP; node within the device, correct?  That seems reasonable to have in a config file describing the device, similar to having an Address parameter.  But given your comment above, it\u0027s possible I misunderstood something about what that parameter was doing functionally, and it\u0027s quite possible that stuff needs reverted.  Ideally it never would\u0027ve merged without working backends in place, but I had a misunderstanding about how much work had actually been upstreamed in this space, and arguably made a mistake letting something as incomplete as it was in.  This seems something that we can fix pretty easily.\n\nBacking out the MCTP parts of that change seems reasonable until a backend actually exists.\n\n\u003e EM supports evaluation of an expression language in its configuration values.\n\nI realize some people have used it as such in their downstream EM forks, but based on lots of feedback, doing it that way is error prone at best, and defeats a lot of the reason the parser was built in the first place, to not have to duplicate the configs for the same device that might take on different modes in different locations.  I suspect we need a better solution in that space than the parser (That doesn\u0027t even implement parsing order properly) for static addressing.\n\n\nWhat I\u0027m not quite understanding is why EID, something that seems like internal bookkeeping that only the BMC needs to be aware of, needs to be static?  Can we walk through that a little bit?\n\nI\u0027d really like to see us break this support up into pieces, one that doesn\u0027t include the idea of static addressing, and just uses assignment (as I think would be the default in any implementation if StaticEndpointID is optional?), then lets try to tackle static assignment, ideally with user-facing descriptions for why a static assignment is required.  What I suspect is that we\u0027re trying to hardcode an EID table somewhere else that isn\u0027t EM enabled, and we want the two to match.;",
      "parentUuid": "dba627e7_a6b16e61",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6c6c41b_af4ffc68",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 50,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-04-04T05:43:29Z",
      "side": 1,
      "message": "\u003e Backing out the MCTP parts of that change seems reasonable until a backend actually exists.\n\nSure.\n\n\u003e What I\u0027m not quite understanding is why EID, something that seems like internal bookkeeping that only the BMC needs to be aware of, needs to be static? Can we walk through that a little bit?\n\nAs a note, there\u0027s a bunch of discussion on this topic on Discord:\n\nhttps://discord.com/channels/775381525260664832/819741065531359263/1225127654743871600\n\n\u003e I\u0027d really like to see us break this support up into pieces, one that doesn\u0027t include the idea of static addressing, and just uses assignment (as I think would be the default in any implementation if StaticEndpointID is optional?)\n\nYep, I\u0027ll do that so we can make some progress with the rest of it.\n\nI\u0027ll also rebase it on top of https://gerrit.openbmc.org/c/openbmc/entity-manager/+/70572",
      "parentUuid": "e2be9cc1_e77056a4",
      "range": {
        "startLine": 50,
        "startChar": 0,
        "endLine": 50,
        "endChar": 76
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2256e4e6_df6e3ca6",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T15:51:24Z",
      "side": 1,
      "message": "What is the difference between an \"MCTPDevice\" and an \"MCTPInterface\"?\n\nAren\u0027t all things Devices that just happen to have an interface?  I\u0027m not sure I understand the distinction.",
      "range": {
        "startLine": 60,
        "startChar": 30,
        "endLine": 60,
        "endChar": 40
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d13acc1e_13c492f6",
        "filename": "schemas/mctp.json",
        "patchSetId": 3
      },
      "lineNbr": 60,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2024-03-05T21:44:08Z",
      "side": 1,
      "message": "Closing. I answered my own question by looking at later patches.",
      "parentUuid": "2256e4e6_df6e3ca6",
      "range": {
        "startLine": 60,
        "startChar": 30,
        "endLine": 60,
        "endChar": 40
      },
      "revId": "8116de14089785f9cd933068a5752cdfd2680319",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}