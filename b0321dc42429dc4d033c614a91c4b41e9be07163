{
  "comments": [
    {
      "key": {
        "uuid": "ad969ca4_794f3077",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-20T12:14:05Z",
      "side": 1,
      "message": "Why do you need this? Are you found some 3-d party device with broken FRU? We have lot of devices, which actually doesn\u0027t follow specification and so most check made as warnings, instead of errors. Here, as I see, you want to silently suppress parsing error.\n\nNote: the check was based on this statement in FRU specification:\n\u003e 5. More on Predefined and Custom Fields \n\u003e If an area is present (as indicated by a non-zero offset in the Common Header) the predefined fields for that area must also be present. The predefined fields can be made ‘Null’, however. This is done by setting the type/length byte to “xx000000” to indicate that the field has no data. All pre-defined fields must be present regardless of whether they are ‘Null’ or not. Custom fields must always be preceded with a type/length byte. The ‘end-of-fields’ byte and area checksum are also required.",
      "range": {
        "startLine": 7,
        "startChar": 5,
        "endLine": 7,
        "endChar": 65
      },
      "revId": "b0321dc42429dc4d033c614a91c4b41e9be07163",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "690c815a_7b5d1415",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1001198
      },
      "writtenOn": "2021-09-20T13:18:25Z",
      "side": 1,
      "message": "As defined in chapter 13 - Type/Length byte format of FRU specification, 2 bits 7:6 are used to indicate \"type code\" and 5 bits 5:0 are used to indicate the \"number of data byte\". In the predefined fields, if the \"type code\" is 11b (8-bits ASCII) and the \"number of data byte\" is 1, the value of this byte is 0xC1. But the 0xC1 value is equal to the \"End of fields\" byte. Therefore, if the software only checks the value of the \"type/length byte\" to indicate \"no more info field\" is the wrong action.\n\nFor example: in the Board Information Area, if the \"Board Part Number\" field has 1 byte of data and the \"code type\" is 11b then the value of Board Part Number type/length byte is 0xC1. In this case, the software made a mistake when detects this byte is \"End of fields\" and returns DecodeState::end. But the truth is Board Information Area has other fields which did not be scanned.\n\nMy solution is checking this field is a \"Custom field\" or not, if this is a \"Custom field\" and the type/length byte is 0xC1, the software shall return DecodeState::end to detect \"no more info field\".",
      "parentUuid": "ad969ca4_794f3077",
      "range": {
        "startLine": 7,
        "startChar": 5,
        "endLine": 7,
        "endChar": 65
      },
      "revId": "b0321dc42429dc4d033c614a91c4b41e9be07163",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6583829b_bc00cde5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1000879
      },
      "writtenOn": "2021-09-20T13:37:01Z",
      "side": 1,
      "message": "The field can\u0027t have len of 1 byte if it use \"8-bits ASCII\" charset (this is defined in chapter 13, exactly same as you reference to):\n\n\u003e 11 - Interpretation depends on Language Codes. 11b indicates 8-bit ASCII + Latin 1 (see below) if the Language Code is English for the area or record containing the field, or 2-byte UNICODE (least significant byte first) if the Language Code is not English. At least two bytes of data must be present when this type is used. Therefore, the length (number of data bytes) will always be \u003e1 if data is present, 0 if data is not present.\n\nSo this mean that the FRU record is invalid and should be fixed. To detect this kind of errors there is a check for \"Non-zero byte after EndOfFields in FRU area\" (see line 446).",
      "parentUuid": "690c815a_7b5d1415",
      "range": {
        "startLine": 7,
        "startChar": 5,
        "endLine": 7,
        "endChar": 65
      },
      "revId": "b0321dc42429dc4d033c614a91c4b41e9be07163",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d88b1491_5970b693",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 7,
      "author": {
        "id": 1001198
      },
      "writtenOn": "2021-09-20T17:38:08Z",
      "side": 1,
      "message": "Thank you very much. I did not check the limitation about length of  type/length byte clearly.\n\nI shall cancel this review.",
      "parentUuid": "6583829b_bc00cde5",
      "range": {
        "startLine": 7,
        "startChar": 5,
        "endLine": 7,
        "endChar": 65
      },
      "revId": "b0321dc42429dc4d033c614a91c4b41e9be07163",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    }
  ]
}