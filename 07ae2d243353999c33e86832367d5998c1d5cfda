{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1cd21a0c_e23c3736",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-16T17:59:18Z",
      "side": 1,
      "message": "This change doesn\u0027t follow cpp core guidelines recommendations.\n\nF.3 https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#f3-keep-functions-short-and-simple\n\n```\nFlag functions that do not ‚Äúfit on a screen.‚Äù How big is a screen? Try 60 lines by 140 characters; that‚Äôs roughly the maximum that‚Äôs comfortable for a book page.\n```\n\nConsidering we don\u0027t allow 140 character line lengths, and this doesn\u0027t enforce 60 line methods, this commit message isn\u0027t accurate.",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 17
      },
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1b2c3b9f_5cc648dc",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-22T16:00:11Z",
      "side": 1,
      "message": "We set the threshold close to the currently largest function to prevent regression.\n\nThe actual goal is the one documented by ISO cpp core guidelines.\n\nThat\u0027s the reason why i am referencing it.\n\nWe cannot set the threshold larger since that would leave room for regression.\n\nWe cannot set the threshold smaller without NOLINTing many functions, which is not the point of this check.",
      "parentUuid": "1cd21a0c_e23c3736",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 17
      },
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "278e01dd_bcd4e8f0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 14,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-10-10T15:13:02Z",
      "side": 1,
      "message": "\u003e We set the threshold close to the currently largest function to prevent regression.\n\nThat\u0027s not what the commit message says.\n\n\u003e \n\u003e The actual goal is the one documented by ISO cpp core guidelines.\n\nCore Guideslines say that enforcing this like you\u0027ve done isn\u0027t correct.\n\n\u003e \n\u003e That\u0027s the reason why i am referencing it.\n\u003e \n\u003e We cannot set the threshold larger since that would leave room for regression.\n\nOnly if people that find this function size threshold useful don\u0027t review.  Please do code reviews for this, and if necessary, run the check offline.\n\n\u003e \n\u003e We cannot set the threshold smaller without NOLINTing many functions, which is not the point of this check.\n\nAgreed.",
      "parentUuid": "1b2c3b9f_5cc648dc",
      "range": {
        "startLine": 13,
        "startChar": 0,
        "endLine": 14,
        "endChar": 17
      },
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f9d0f069_20f7dbbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-10T16:07:23Z",
      "side": 1,
      "message": "I\u0027m not interested in maintaining a threshold so close to the largest at this time.  Maintaining a hard threshold requires that I have to reject patches that make functions longer.\n\nI would be in support of a threshold that had ~30-50% margin on the longest length present in the repo today, so we\u0027d prevent new regressions.",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "820e788f_f86d680c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-11T08:22:50Z",
      "side": 1,
      "message": "\u003e Maintaining a hard threshold requires that I have to reject patches that make functions longer.\n\nIf there is a good reason (such as `clang-format` requiring it or some other tradeoff), we can always increase this threshold. It does not mean you have to reject all patches which increase it.\n\n\n\n\n\u003e I would be in support of a threshold that had ~30-50% margin on the longest length present in the repo today, so we\u0027d prevent new regressions.\n\nIMO your idea is actually encouraging regressions since we would leave space for them to occur unnoticed.\n\nExample:\n\nIf our longest function is e.g. `100` lines, and we set the threshold to `150` (50% margin), and a patch `P1` comes in which increases the size of that function to `120` lines, it will not be flagged by the check.\n\nThen when `P1` gets merged we get:\n\n- a regression on following cpp core guidelines and readability\n- a mismatch with your goal to have a 50% margin\n\n\nSo instead of using some percentage of margin, we can closely follow the largest function, adjust if necessary, and make sure we are proceeding in the right direction.\n\nMy intent with this change and threshold is that any patch which makes the problem worse (increasing the size of our largest functions and making the code less readable) has to document that it\u0027s doing so by adjusting this threshold to match.\n\nWhat do you think üòä",
      "parentUuid": "f9d0f069_20f7dbbb",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9c19d04_9ef021cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-11T13:42:35Z",
      "side": 1,
      "message": "Let\u0027s go back to where you documented this as a desired check https://github.com/openbmc/docs/commit/ba560cc31297caddfc157c540ae9e6d760d630e5\n\nand specifically, with the original value of `60`, which was taken directly from C++ core guidelines.\n\n\u003e These two checks around cognative complexity and function size were put\nin this file aspirationally.  To date no repositories have been able to\nsuccessfully enable these two checks.  This maintainer has personally\ntried and we\u0027d either have to bypass so many functions that the check\nbecame more cumbersome to maintain, or we\u0027d have to raise the limits to\nwhere they were not useful.  While I\u0027m hopeful that these checks could\nbe enabled in the future, they don\u0027t match the reality of where tidy is\nat.\n\nand you listed an overly large limit as `no longer useful`.\n\nNow you want to raise the limit above where the codebase is currently at.\n\nThis is going against the documented intention of moving to the documented value for this check.\n\n\u003e To date no repositories have been able to\nsuccessfully enable these two checks.\n\nEM is now able to enable this check at a reasonable value of 170.\n\nLet\u0027s not mess up this opportunity, it might not come back.\n\nIf we do not enable this check now, 20 patches later we might be at 200 or 250 lines for the longest function.",
      "parentUuid": "820e788f_f86d680c",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c5c3c0e_7f432ecd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-11T16:27:51Z",
      "side": 1,
      "message": "\u003e Let\u0027s go back to where you documented this as a desired check https://github.com/openbmc/docs/commit/ba560cc31297caddfc157c540ae9e6d760d630e5\n\nTo be clear, we now differentiate between \"These checks are able to be enabled\" and \"These are checks people are trying to enable\" I made it very clear in the review that I don\u0027t find that check to hit the threshold of general usefulness at this point, and I think it can be actively combative to people trying to fix one thing, or clean up code.\n\n\u003e \n\u003e and specifically, with the original value of `60`, which was taken directly from C++ core guidelines.\n\nCPP core guidelines also says to not enforce it because there are exceptions, so if our argument is based on that, this patchset is incorrect.\n\n\u003e \n\u003e \u003e These two checks around cognative complexity and function size were put\n\u003e in this file aspirationally.  To date no repositories have been able to\n\u003e successfully enable these two checks.  This maintainer has personally\n\u003e tried and we\u0027d either have to bypass so many functions that the check\n\u003e became more cumbersome to maintain, or we\u0027d have to raise the limits to\n\u003e where they were not useful.  While I\u0027m hopeful that these checks could\n\u003e be enabled in the future, they don\u0027t match the reality of where tidy is\n\u003e at.\n\u003e \n\u003e and you listed an overly large limit as `no longer useful`.\n\u003e \n\u003e Now you want to raise the limit above where the codebase is currently at.\n\nTo be clear, at this time, I don\u0027t think this check helps with maintenance, and I as a maintainer am not interested in enabling it.  If the other maintainers here are interested in maintaining it, I\u0027m happy to have that discussion.\n\nIf we got the codebase to the point where we passed the 60 line rule, THEN we enforced a size that\u0027s larger than that, that\u0027s something I could be in support of, but in that order, with abstraction patterns that show we can actually get the line count down.\n\n\u003e \n\u003e This is going against the documented intention of moving to the documented value for this check.\n\nThat\u0027s not what the \"desired\" list intends.  The desired list is \"someone is trying to enable this, and the project doesn\u0027t immediately see objections to that\".  The desired list also keeps the default of 60 lines, which this patchset doesn\u0027t so arguing that this matches the desired tidy doesn\u0027t track for me.\n\n\u003e \n\u003e \u003e To date no repositories have been able to\n\u003e successfully enable these two checks.\n\u003e \n\u003e EM is now able to enable this check at a reasonable value of 170.\n\nThis is the point, you and I disagree that 170 is reasonable.  There is nothing documented that says that 170 is reasonable and 171 is unreasonable, so when someone checks in a 171 line method (or more likely adds to the 170 line method) I as the maintainer now have to take time to explain the background of why their (theoretical) one line bug fix has to include a multi line refactor.\n\n\u003e \n\u003e Let\u0027s not mess up this opportunity, it might not come back.\n\u003e \n\u003e If we do not enable this check now, 20 patches later we might be at 200 or 250 lines for the longest function.\n\nThis assumes that maintainers don\u0027t do their jobs, and that there\u0027s significant active development going on.  I routinely (even an hour ago) commented that a function needed to be made shorter and utilities broken out.  We\u0027ve continued to improve over time without this check, I suspect it will continue to happen in its absence.\n\nThe opportunity here is to work on breaking down the largest functions and add unit tests where appropriate, not enabling some blanket check that isn\u0027t an easy refactor for people new to the project to make.",
      "parentUuid": "b9c19d04_9ef021cb",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "920df166_462d7640",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-15T08:35:20Z",
      "side": 1,
      "message": "I",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30dfd272_ab82a4b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-15T08:35:20Z",
      "side": 1,
      "message": "\u003e I made it very clear in the review that I don\u0027t find that check to hit the threshold of general usefulness at this point, and I think it can be actively combative to people trying to fix one thing, or clean up code.\n\nMaybe you are completely alone in this opinion. You are the only one objecting to this patch.\n\nDid you maintain a repo with this check enabled before? In case it\u0027s new to you, does it make sense to go for a trial run where we enable this check and see how it goes?\n\nI guess it would not be too much work for you to extract functions where appropriate in your EM development. You are really good at C++ and would almost never hit any problem with this check.\n\n\u003e This assumes that maintainers don\u0027t do their jobs, and that there\u0027s significant active development going on.\n\nRelying on maintainers for this specific issue **did not work in the past**, and i am *doubting* it will work in the future.\n\nI also consider it some waste of time to manually keep track of this issue which is why this check exists.\n\n\u003e not enabling some blanket check that isn\u0027t an easy refactor for people new to the project to make.\n\nFrom my (beginner) perspective, it is easier to contribute in a codebase with smaller functions which is more readable.\n\nUnderstanding the code is the hard part. Extracting a function is usually an easy task.\n\nWhich is why there is IDE\u0027s like CLion and others where extracting a function is already automated.\n\nMaybe you cannot take this perspective because of your experience. You would not have issues understanding these larger functions.",
      "parentUuid": "1c5c3c0e_7f432ecd",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a7c6a197_291c1d9c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-16T17:53:38Z",
      "side": 1,
      "message": "\u003e \u003e I made it very clear in the review that I don\u0027t find that check to hit the threshold of general usefulness at this point, and I think it can be actively combative to people trying to fix one thing, or clean up code.\n\u003e \n\u003e Maybe you are completely alone in this opinion. You are the only one objecting to this patch.\n\nIf that\u0027s true, then I\u0027m happy to see other folks chime in here.\n\nIf this were true, we\u0027d be able to point at all the other maintainers that have enabled this check in their maintained repos.  Maybe there are some that have had a better experience with this check?\n\n\u003e \n\u003e Did you maintain a repo with this check enabled before? In case it\u0027s new to you, does it make sense to go for a trial run where we enable this check and see how it goes?\n\nI have attempted to maintain this repo with this check not enforced, but run manually.  It was actively an issue in maintenance when doing things like reformatting, and constantly needed adjusted when doing maintenance.  As stated before, this check doesn\u0027t correctly count the longest lambda methods, so it limits its usefulness in actually detecting where the problems are.  If that were fixed in clang-tidy itself, I\u0027d be a lot more willing to enable this.\n\n\u003e \n\u003e I guess it would not be too much work for you to extract functions where appropriate in your EM development. You are really good at C++ and would almost never hit any problem with this check.\n\nI have no doubt that for MY patches, I could handle this check.  Where I\u0027m worried is about other peoples patches and maintenance activities (reformatting, rebasing etc).\n\n\u003e \n\u003e \u003e This assumes that maintainers don\u0027t do their jobs, and that there\u0027s significant active development going on.\n\u003e \n\u003e Relying on maintainers for this specific issue **did not work in the past**, and i am *doubting* it will work in the future.\n\nConsidering the majority of OpenBMC users either have transitioned or are transitioning to dbus-sensors over the alternatives like phosphor-hwmon, I would say the end goal was accomplished, even if we did it with longer-than-we-would like methods.\n\n\u003e \n\u003e I also consider it some waste of time to manually keep track of this issue which is why this check exists.\n\nThis check does not correctly enforce the intent, that\u0027s the gap.\n\n\u003e \n\u003e \u003e not enabling some blanket check that isn\u0027t an easy refactor for people new to the project to make.\n\u003e \n\u003e From my (beginner) perspective, it is easier to contribute in a codebase with smaller functions which is more readable.\n\u003e \n\u003e Understanding the code is the hard part. Extracting a function is usually an easy task.\n\u003e \n\u003e Which is why there is IDE\u0027s like CLion and others where extracting a function is already automated.\n\nGreat, lets start putting together patches to clean that up.\n\n\u003e \n\u003e Maybe you cannot take this perspective because of your experience. You would not have issues understanding these larger functions.\n\n\nI agree, we should strive for better interfaces, which probably_ means smaller functions  The issue in this review is not that, it\u0027s that the tidy check we\u0027re enabling:\n1. Doesn\u0027t match the standard we code against.\n2. Is set to enforce a limit that\u0027s made up and that I don\u0027t want to maintain.\n3. Doesn\u0027t correctly enforce that standard for lambdas.\n\nI would like to see continued effort in actually cleaning up these.",
      "parentUuid": "30dfd272_ab82a4b3",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02050ac9_e455daf7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-22T16:00:11Z",
      "side": 1,
      "message": "\u003e If that\u0027s true, then I\u0027m happy to see other folks chime in here.\n\nSure, i have posted in discord to get some input here for community alignment.\n\n\n\u003e If this were true, we\u0027d be able to point at all the other maintainers that have enabled this check in their maintained repos. Maybe there are some that have had a better experience with this check?\n\nSince there has been a bunch of rework in entity-manager lately, i think it is on a good path to enable this check at a reasonable value which reflects the current state of the code.\n\nI am starting to enable this check here because i see a realistic path to clean things up even further. There are other repos which are a lost cause in this regard and would be too much work to clean up. So we can be happy to have this opportunity here where we can aspire to achieve readability like that.\n\n\u003e This check does not correctly enforce the intent, that\u0027s the gap.\n\nThe intent of the patch is to prevent regression on what we have already achieved in this repo.\n\n\u003e Great, lets start putting together patches to clean that up.\n\nYes, and this patch will help to prevent any regression in the meantime. So we do not accidentally merge some patch which increases the problem again.\n\n\n\u003e Doesn\u0027t match the standard we code against.\n\nI am not pulling this value out of this air. It is a direct result of all the patches you and Matt merged. So it is directly representative of the current state of the code.\n\n(which is pretty good compared to some other repos out there, so thanks for the efforts üëç)\n\nIf we prevent any regression there then we are on a good path to improve further üòä\n\n\u003e Is set to enforce a limit that\u0027s made up and that I don\u0027t want to maintain.\n\nLet\u0027s clarify, there is not much to actively maintain. The check should maintain itself.\n\n\u003e I would like to see continued effort in actually cleaning up these.\n\nSure, and i would be happy for your support in this effort by preventing any regressions on what we have already achieved. Which is what this patch tries to do.\n\n\nI am really struggling to understand the \n\n\"i want to go to X but i do not want to enforce X+70 because that is not where i want to go\" mentality.\n\nIt\u0027s like climbing a mountain but forgetting to clip in at different points.\nOne bad patch or review oversight and we fall down to 200 or 250 and lose a bunch of progress and start from the beginning again.\n\n\nI do not want to start from the beginning again. I do not want to be out for a month and then come back and see some kind of surprise. I want to achieve something, and then make sure we do not loose it again, either by unit tests or clang-tidy checks.",
      "parentUuid": "a7c6a197_291c1d9c",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7e9492f_6d09347d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-10-10T14:45:59Z",
      "side": 1,
      "message": "As long as we can avoid the burden on small change uploaders to have to refactor a whole function just because their adding hits the threshold, this config helps the maintaining process above all.",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "757ea2b6_2c35e9af",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-10-10T14:53:53Z",
      "side": 1,
      "message": "But how does this patch accomplish avoiding the burden?  It pushes it to maintainers.",
      "parentUuid": "b7e9492f_6d09347d",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67975b82_0a172db2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-10-10T15:13:02Z",
      "side": 1,
      "message": "I\u0027ve made my position clear.  To proceed with this:\n1. Figure out a check that enforces lengths correctly (including lambdas).\n2. Refactor the code so that it hits cpp core guidelines recommendations.\n\nThen we can talk about enforcing an automated check.\n\nAlternatively, there\u0027s lots of other repositories that could likely use this check where maybe the maintainers aren\u0027t as swamped with reviews and have time to define how this new enforcement works in terms of review velocity.  Feel free to enable on those.",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cc6da2db_a8fbacec",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-10-10T15:13:02Z",
      "side": 1,
      "message": "Would love to see all the patches refactoring commits to make them smaller.\n\nYou\u0027ve completely glossed over that no other maintainers in the project have enabled this check and gotten to the appropriate size, so at least amongst maintainers I don\u0027t seem to be alone.\n\nThe check we\u0027ve enabled here doesn\u0027t accomplish setting a real threshold, due to limitations in clang-tidy.\n\n\u003e \n\u003e Yes, and this patch will help to prevent any regression in the meantime.\n\nI will review in the meantime and ensure that the longest function doesn\u0027t get any longer (within reason).\n\n\u003e \n\u003e \n\u003e \u003e Doesn\u0027t match the standard we code against.\n\u003e \n\u003e I am not pulling this value out of this air. It is a direct result of all the patches you and Matt merged. So it is directly representative of the current state of the code.\n\nWith respect, most of the code you\u0027re complaining about was committed before Matt or I were maintainers on this repository.  Please tone down your accusatory language for those that are actively trying to help you.  Like I said, I\u0027m happy to see improvements made, where I draw the line is arbitrary thresholds.\n\n\u003e \n\u003e \u003e Is set to enforce a limit that\u0027s made up and that I don\u0027t want to maintain.\n\u003e \n\u003e Let\u0027s clarify, there is not much to actively maintain. The check should maintain itself.\n\u003e \n\u003e \u003e I would like to see continued effort in actually cleaning up these.\n\u003e \n\u003e Sure, and i would be happy for your support in this effort by preventing any regressions on what we have already achieved. Which is what this patch tries to do.\n\u003e \n\u003e \n\u003e I am really struggling to understand the \n\u003e \n\u003e \"i want to go to X but i do not want to enforce X+70 because that is not where i want to go\" mentality.\n\u003e \n\u003e It\u0027s like climbing a mountain but forgetting to clip in at different points.\n\u003e One bad patch or review oversight and we fall down to 200 or 250 and lose a bunch of progress and start from the beginning again.\n\nAs someone who used to mountain climb a lot, I\u0027ll extend your analogy, this is the equivalent of clipping into your car in the parking lot.  The safety margin here isn\u0027t useful until someone actually starts to \"climb\" by refactoring methods to be smaller, and you\u0027ve clipped to something that isn\u0027t a safety device and won\u0027t prevent you from falling.\n\nIf we start actually refactoring to where we\u0027re close to the threshold, I\u0027m happy to discuss this once the check is made to be correct.\n\n\u003e \n\u003e \n\u003e I do not want to start from the beginning again. I do not want to be out for a month and then come back and see some kind of surprise. I want to achieve something, and then make sure we do not loose it again, either by unit tests or clang-tidy checks.\n\nThere is nothing in this check that prevents that.  Someone could disable the check in the next commit \"while you\u0027re out\".  I will do my best as maintainer to hold the line to within reason, I just don\u0027t want to see it enforced at CI time.",
      "parentUuid": "02050ac9_e455daf7",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}