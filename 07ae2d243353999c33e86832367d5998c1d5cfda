{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f9d0f069_20f7dbbb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-10T16:07:23Z",
      "side": 1,
      "message": "I\u0027m not interested in maintaining a threshold so close to the largest at this time.  Maintaining a hard threshold requires that I have to reject patches that make functions longer.\n\nI would be in support of a threshold that had ~30-50% margin on the longest length present in the repo today, so we\u0027d prevent new regressions.",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "820e788f_f86d680c",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-11T08:22:50Z",
      "side": 1,
      "message": "\u003e Maintaining a hard threshold requires that I have to reject patches that make functions longer.\n\nIf there is a good reason (such as `clang-format` requiring it or some other tradeoff), we can always increase this threshold. It does not mean you have to reject all patches which increase it.\n\n\n\n\n\u003e I would be in support of a threshold that had ~30-50% margin on the longest length present in the repo today, so we\u0027d prevent new regressions.\n\nIMO your idea is actually encouraging regressions since we would leave space for them to occur unnoticed.\n\nExample:\n\nIf our longest function is e.g. `100` lines, and we set the threshold to `150` (50% margin), and a patch `P1` comes in which increases the size of that function to `120` lines, it will not be flagged by the check.\n\nThen when `P1` gets merged we get:\n\n- a regression on following cpp core guidelines and readability\n- a mismatch with your goal to have a 50% margin\n\n\nSo instead of using some percentage of margin, we can closely follow the largest function, adjust if necessary, and make sure we are proceeding in the right direction.\n\nMy intent with this change and threshold is that any patch which makes the problem worse (increasing the size of our largest functions and making the code less readable) has to document that it\u0027s doing so by adjusting this threshold to match.\n\nWhat do you think ðŸ˜Š",
      "parentUuid": "f9d0f069_20f7dbbb",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9c19d04_9ef021cb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-11T13:42:35Z",
      "side": 1,
      "message": "Let\u0027s go back to where you documented this as a desired check https://github.com/openbmc/docs/commit/ba560cc31297caddfc157c540ae9e6d760d630e5\n\nand specifically, with the original value of `60`, which was taken directly from C++ core guidelines.\n\n\u003e These two checks around cognative complexity and function size were put\nin this file aspirationally.  To date no repositories have been able to\nsuccessfully enable these two checks.  This maintainer has personally\ntried and we\u0027d either have to bypass so many functions that the check\nbecame more cumbersome to maintain, or we\u0027d have to raise the limits to\nwhere they were not useful.  While I\u0027m hopeful that these checks could\nbe enabled in the future, they don\u0027t match the reality of where tidy is\nat.\n\nand you listed an overly large limit as `no longer useful`.\n\nNow you want to raise the limit above where the codebase is currently at.\n\nThis is going against the documented intention of moving to the documented value for this check.\n\n\u003e To date no repositories have been able to\nsuccessfully enable these two checks.\n\nEM is now able to enable this check at a reasonable value of 170.\n\nLet\u0027s not mess up this opportunity, it might not come back.\n\nIf we do not enable this check now, 20 patches later we might be at 200 or 250 lines for the longest function.",
      "parentUuid": "820e788f_f86d680c",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1c5c3c0e_7f432ecd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2025-09-11T16:27:51Z",
      "side": 1,
      "message": "\u003e Let\u0027s go back to where you documented this as a desired check https://github.com/openbmc/docs/commit/ba560cc31297caddfc157c540ae9e6d760d630e5\n\nTo be clear, we now differentiate between \"These checks are able to be enabled\" and \"These are checks people are trying to enable\" I made it very clear in the review that I don\u0027t find that check to hit the threshold of general usefulness at this point, and I think it can be actively combative to people trying to fix one thing, or clean up code.\n\n\u003e \n\u003e and specifically, with the original value of `60`, which was taken directly from C++ core guidelines.\n\nCPP core guidelines also says to not enforce it because there are exceptions, so if our argument is based on that, this patchset is incorrect.\n\n\u003e \n\u003e \u003e These two checks around cognative complexity and function size were put\n\u003e in this file aspirationally.  To date no repositories have been able to\n\u003e successfully enable these two checks.  This maintainer has personally\n\u003e tried and we\u0027d either have to bypass so many functions that the check\n\u003e became more cumbersome to maintain, or we\u0027d have to raise the limits to\n\u003e where they were not useful.  While I\u0027m hopeful that these checks could\n\u003e be enabled in the future, they don\u0027t match the reality of where tidy is\n\u003e at.\n\u003e \n\u003e and you listed an overly large limit as `no longer useful`.\n\u003e \n\u003e Now you want to raise the limit above where the codebase is currently at.\n\nTo be clear, at this time, I don\u0027t think this check helps with maintenance, and I as a maintainer am not interested in enabling it.  If the other maintainers here are interested in maintaining it, I\u0027m happy to have that discussion.\n\nIf we got the codebase to the point where we passed the 60 line rule, THEN we enforced a size that\u0027s larger than that, that\u0027s something I could be in support of, but in that order, with abstraction patterns that show we can actually get the line count down.\n\n\u003e \n\u003e This is going against the documented intention of moving to the documented value for this check.\n\nThat\u0027s not what the \"desired\" list intends.  The desired list is \"someone is trying to enable this, and the project doesn\u0027t immediately see objections to that\".  The desired list also keeps the default of 60 lines, which this patchset doesn\u0027t so arguing that this matches the desired tidy doesn\u0027t track for me.\n\n\u003e \n\u003e \u003e To date no repositories have been able to\n\u003e successfully enable these two checks.\n\u003e \n\u003e EM is now able to enable this check at a reasonable value of 170.\n\nThis is the point, you and I disagree that 170 is reasonable.  There is nothing documented that says that 170 is reasonable and 171 is unreasonable, so when someone checks in a 171 line method (or more likely adds to the 170 line method) I as the maintainer now have to take time to explain the background of why their (theoretical) one line bug fix has to include a multi line refactor.\n\n\u003e \n\u003e Let\u0027s not mess up this opportunity, it might not come back.\n\u003e \n\u003e If we do not enable this check now, 20 patches later we might be at 200 or 250 lines for the longest function.\n\nThis assumes that maintainers don\u0027t do their jobs, and that there\u0027s significant active development going on.  I routinely (even an hour ago) commented that a function needed to be made shorter and utilities broken out.  We\u0027ve continued to improve over time without this check, I suspect it will continue to happen in its absence.\n\nThe opportunity here is to work on breaking down the largest functions and add unit tests where appropriate, not enabling some blanket check that isn\u0027t an easy refactor for people new to the project to make.",
      "parentUuid": "b9c19d04_9ef021cb",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "920df166_462d7640",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-15T08:35:20Z",
      "side": 1,
      "message": "I",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30dfd272_ab82a4b3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-15T08:35:20Z",
      "side": 1,
      "message": "\u003e I made it very clear in the review that I don\u0027t find that check to hit the threshold of general usefulness at this point, and I think it can be actively combative to people trying to fix one thing, or clean up code.\n\nMaybe you are completely alone in this opinion. You are the only one objecting to this patch.\n\nDid you maintain a repo with this check enabled before? In case it\u0027s new to you, does it make sense to go for a trial run where we enable this check and see how it goes?\n\nI guess it would not be too much work for you to extract functions where appropriate in your EM development. You are really good at C++ and would almost never hit any problem with this check.\n\n\u003e This assumes that maintainers don\u0027t do their jobs, and that there\u0027s significant active development going on.\n\nRelying on maintainers for this specific issue **did not work in the past**, and i am *doubting* it will work in the future.\n\nI also consider it some waste of time to manually keep track of this issue which is why this check exists.\n\n\u003e not enabling some blanket check that isn\u0027t an easy refactor for people new to the project to make.\n\nFrom my (beginner) perspective, it is easier to contribute in a codebase with smaller functions which is more readable.\n\nUnderstanding the code is the hard part. Extracting a function is usually an easy task.\n\nWhich is why there is IDE\u0027s like CLion and others where extracting a function is already automated.\n\nMaybe you cannot take this perspective because of your experience. You would not have issues understanding these larger functions.",
      "parentUuid": "1c5c3c0e_7f432ecd",
      "revId": "07ae2d243353999c33e86832367d5998c1d5cfda",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}