{
  "comments": [
    {
      "key": {
        "uuid": "5ae985e1_7e8b9217",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 38,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-06-08T04:44:44Z",
      "side": 1,
      "message": "can you give an explicit part number example here?   Not all PCA family are muxes.",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "652e88df_4367775c",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 38,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-14T23:48:41Z",
      "side": 1,
      "message": "Sure, we generally have all supported PCA muxes added in device.hpp file.",
      "parentUuid": "5ae985e1_7e8b9217",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b62202cd_41162fd8",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 43,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-17T17:14:40Z",
      "side": 1,
      "message": "I went back and read all the comment threads, and I think I understand where the contention is:\n\nThis paragraph says that Entity Manager is going to use GPIOs exposed by the platform to add logical busses.   To allow devices under more than one mux channel, the kernel needs to control the mux to allow proper access locking of the i2c bus.\n\nThe current kernel mux code has support for gpio control through the device tree, or through a configuration structure passed via platform data.   For a truly dynamic addition someone will need to add a kernel driver.\n\nIf the goal of these entity manager patches is just to describe which bus its on then I\u0027m ok with having it follow sysfs though the mux to find the i2c bus number assigned to the segment.  But if there is more than one segement that can have a device at a time, the kernel must be aware and in control.",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b45c3914_cfa16793",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 43,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-20T19:10:19Z",
      "side": 1,
      "message": "Entity manager job is just to find logical bus number after mux driver gets initialized and map back to it\u0027s device configuration. None of devices are accessed without kernel driver so kernel will be aware of all of those operations.",
      "parentUuid": "b62202cd_41162fd8",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b5740478_12123cff",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 43,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-20T20:01:43Z",
      "side": 1,
      "message": "what do you mean by \"after initializing mux driver via entity manager\" ?\n\nI thought this was dynamically instantiating a mux driver.   If its just deferring instantiation of devices behind a planar mux I\u0027m ok but would like some wording changed.  (I don\u0027t see code upstream to supply a generic mux config via GPIO, but PCA muxes should self configure).\n\nYour text and examples below says you will set some gpios then call a kernel driver.  But you are showing conflicting states of those gpios and have not described any exclusion.",
      "parentUuid": "b45c3914_cfa16793",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ed8f7bb7_249bea32",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 43,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-24T00:57:48Z",
      "side": 1,
      "message": "Mux driver would be dynamically instantiated by entity manager only via overlay code which is currently happening in current code. As soon as it gets instantiated logical bus number would be populated for each device behind mux and then those device driver will get instantiated on a logical bus and given address.\n\nI am in the process of having code for finding logical bus number and updating configuration file.",
      "parentUuid": "b5740478_12123cff",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ec3dac1e_2ecaa27f",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 66,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2021-06-07T23:52:18Z",
      "side": 1,
      "message": "Do we basically put an IÂ²C topology for all the FRUs that has multiple I2C muxes and each of them will have fixed number of connections? Is this only for like sensors?\n\nWhat if we want to have dynamic connection like a FRU that has multiple slots that connects to more FURs. Will that work?\n\nWith that it is not guarantee that all the FRUs are connected. Those FRUs will be a board itself. Do we just want a mapping to the address/bus that we know... and then look at the actual FRU instead?",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 66,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "02dc5e1b_4b3bd7af",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 66,
      "author": {
        "id": 1000885
      },
      "writtenOn": "2021-06-08T16:19:55Z",
      "side": 1,
      "message": "For the FRUs, does the Entity Manager just have to keep track of this mapping and update the Slot name on the board/FRU if it is suppose to be connected to another board/FRU.",
      "parentUuid": "ec3dac1e_2ecaa27f",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 66,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "831ad83a_263e044d",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 66,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-14T23:48:41Z",
      "side": 1,
      "message": "Let me clarify here, FRU is mainly used for detecting and probing to get a bus number. If you have bus number predefined and want to have different probing mechanism, entity manager doesn\u0027t care as long as probe returns true it will add the respective config file. And if any $bus or $address is used in that file it will be replaced by actual i2c bus number found by FRU interface.\n\nEach mapping is separate for each found card.",
      "parentUuid": "02dc5e1b_4b3bd7af",
      "range": {
        "startLine": 48,
        "startChar": 0,
        "endLine": 66,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d6afa852_aca61351",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000632
      },
      "writtenOn": "2021-06-15T22:53:15Z",
      "side": 1,
      "message": "Will this bus number be replaced by the logical bus number? If so, is there a plan how to replace?",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "233534a7_7b1ec3c6",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-16T20:03:15Z",
      "side": 1,
      "message": "Yes, i am working on code for this. I will update design once I have complete working code.",
      "parentUuid": "d6afa852_aca61351",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fb5f2b58_2cd17997",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000632
      },
      "writtenOn": "2021-06-23T01:41:37Z",
      "side": 1,
      "message": "I was wondering how to implement this. In order find the logical bus number, you need to know the $bus, $address and $channel. $bus.Slot_1 is not unique, when you have multiple mux devices on a I2C bus.",
      "parentUuid": "233534a7_7b1ec3c6",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8ea0e031_65e30be7",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-23T22:08:03Z",
      "side": 1,
      "message": "you already know $bus, you are getting address and Slot_1 is your channel number.",
      "parentUuid": "fb5f2b58_2cd17997",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c348ebe5_3da9ae04",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000502
      },
      "writtenOn": "2021-06-23T22:28:13Z",
      "side": 1,
      "message": "Jie is right. It is possible to have more than one I2C mux on the same $bus. e.g. one at 0x70 and another at 0x71. I haven\u0027t personally run into this situation, but I suppose it could happen.\n\nSlot_1 is specified in the ChannelNames list above. So maybe this is fine as is? The user can select different names for the second mux.",
      "parentUuid": "8ea0e031_65e30be7",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cbf29394_2459bf39",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000632
      },
      "writtenOn": "2021-06-23T23:17:25Z",
      "side": 1,
      "message": "if you you have a nested device with Bus property \"$bus.Slot_1_0\", you might not find the logical bus number, as \"$bus.Slot_1\" might bot be unique. You need to know the address of \"$bus.Slot_1\" that is not shown the device properties.",
      "parentUuid": "c348ebe5_3da9ae04",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f7c5145_bc04c92d",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 110,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-29T22:09:46Z",
      "side": 1,
      "message": "logical bus number are directly mapped to channel names and are unique. So as soon as we see these channel names we will try to find its logical bus number and create a map. Then while parsing $bus.Slot_1_0 will be replaced accordingly. I am even thinking of keeping these as 2 separate field as I am finding difficult in parsing everything in the same property. I will update this as a next patch after verifying implementation.",
      "parentUuid": "cbf29394_2459bf39",
      "range": {
        "startLine": 110,
        "startChar": 16,
        "endLine": 110,
        "endChar": 27
      },
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "89278d2d_dddcf9f8",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-06-08T04:44:44Z",
      "side": 1,
      "message": "That part is definitly a input pin controlled mux, with additional enable controls that is beyond the current mux framework that the i2c gpio mux driver uses, but could easily be extended to suppot.\n\nAre you trying to only use one channel of the above device to implement a switch?\n\nMaybe we need to split the two use cases.",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "112452be_96cc56d2",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-14T23:48:41Z",
      "side": 1,
      "message": "We can certainly add more support of kernel driver. Currently we are going to support pin controlled switch.",
      "parentUuid": "89278d2d_dddcf9f8",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "05de4a70_37fa1715",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-17T17:14:40Z",
      "side": 1,
      "message": "I added a statement above at 43 in patch 6.  If its more than an off-off switch and you need devices on more than one channel, the kernel must control the mux.",
      "parentUuid": "112452be_96cc56d2",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4b495b36_42a43af5",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-20T19:10:19Z",
      "side": 1,
      "message": "It is just a on/off switch to enable a particular device. Once device is enabled then its kernel driver will be initialized. For each board there will be one configuration which will expose certain channel. And it is one time, EM is not going to switch back and forth for controlling mux.",
      "parentUuid": "05de4a70_37fa1715",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a73c6f4a_6d15c6e3",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-20T20:01:43Z",
      "side": 1,
      "message": "The part you showed can only enable one downstream segment, because the selectors are decoded and not one-hot enables.  So is entity manager also going to take care to unbind all switched deivices before allowing any other device to be selected?\n\nOtherwise we are back to needing a kernel driver for this mux application.\n\nYour example shows 2 TMP421 on different channels.",
      "parentUuid": "4b495b36_42a43af5",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8b4823c6_1137c08e",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-24T00:57:48Z",
      "side": 1,
      "message": "My assumption here is all the devices are one time configuration at a particular running session. But I agree if we change switch selection then it needs to unbind all devices. Currently I will keep it simple with single type configuration and add more complexity later on.",
      "parentUuid": "a73c6f4a_6d15c6e3",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "03c987fb_17d9e594",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 185,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-24T01:39:48Z",
      "side": 1,
      "message": "So you are conceeding the limitations but they are not stated.\n\nA significant limitation is only one downstream port without a driver, and some method to enforce that only the first used is selected.\n\nAlternatively an appropriate driver removes the limitations but if you have both now you need to differentiate which applies.  An overlay as described sounds like a good plan (although I have not researched what is upstream vs popular downstream).\n\nIf you express the limitations here and how they are enforced I\u0027m ok with a tactical solution.",
      "parentUuid": "8b4823c6_1137c08e",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c9ad95f_cb71a772",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-06-08T04:44:44Z",
      "side": 1,
      "message": "I think we need a better statement of what benefits we are getting by not describing the mux to the kernel with a proper i2c mux driver.\n\nIf the only benefit is describing to entity manager what to probe on a given bus then lets clearly state that.",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3a7a1e20_bfb144b5",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-14T23:48:41Z",
      "side": 1,
      "message": "We are getting a dynamic access to any add on card so we don\u0027t need to describe this in kernel earlier. It will eventually get added as soon as card is detected via entity manager configuration.",
      "parentUuid": "8c9ad95f_cb71a772",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "14dba945_c1556eb8",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-06-16T00:04:40Z",
      "side": 1,
      "message": "Where are the gpio and isolator physically?\n\nYou said the gpios should be named why not describe the connection to the muxes?\n\nIf the gpios are on the support to the plug in card with different muxes on the card then this makes some sense.  However if they are on the same card, especially if you expect to have more than a static configuration once a set of cards are plugged, then it should be kernel controlled.\n\nI don\u0027t have a strong sense of how the userspace learns the content of the cards, other than it should be reasonably easy to describe and create by humans as well as machines.",
      "parentUuid": "3a7a1e20_bfb144b5",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "640c478c_40c97829",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-06-16T20:22:31Z",
      "side": 1,
      "message": "This gpio switch is on main board but it can be anywhere. It is completely dynamic and you define slot number based on gpio line combinations. So EM will set those gpio lines before accessing each slots card. a great example for that is battery sensors.\n\nUser space has to dynamically detect which card is connected and what all it has via configuration file. So kernel have no idea what card is connected in expansion slot until it\u0027s driver is initialized.",
      "parentUuid": "14dba945_c1556eb8",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "40c53b4d_7215e619",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-17T17:14:40Z",
      "side": 1,
      "message": "This is in alternatives considered, so we do not need to debate how user space control is a broken model.",
      "parentUuid": "640c478c_40c97829",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "cb0bfc51_8c757fa4",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 231,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-20T19:10:19Z",
      "side": 1,
      "message": "This dynamic model is provide a flexibility to configure a board with certain configuration.",
      "parentUuid": "40c53b4d_7215e619",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "ebeb7601_3f43dc15",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 236,
      "author": {
        "id": 1000021
      },
      "writtenOn": "2021-08-17T17:14:40Z",
      "side": 1,
      "message": "If it resolves the bus number then state that.   But I don\u0027t understand why entity manager is involved more than a hotplug enable switch.   It can\u0027t be in control of the mux if there are sensors below, and any vpd has to be removed before changing the mux from userspace.",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd701b57_76b0f137",
        "filename": "docs/dynamic_mux.md",
        "patchSetId": 6
      },
      "lineNbr": 236,
      "author": {
        "id": 1000271
      },
      "writtenOn": "2021-08-20T19:10:19Z",
      "side": 1,
      "message": "EM is not controlling mux, it is detecting devices based on configuration and providing device details to other daemons.",
      "parentUuid": "ebeb7601_3f43dc15",
      "revId": "977ebf82a26379790f119b3686d6a4bdfd421216",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4",
      "unresolved": false
    }
  ]
}