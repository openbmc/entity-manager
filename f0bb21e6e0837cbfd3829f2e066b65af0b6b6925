{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "be8cf350_cc4c803b",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 466,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T08:30:31Z",
      "side": 1,
      "message": "lg2::debug",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "60bc8fa8_bd40e8b0",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 466,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-09-17T16:56:51Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "be8cf350_cc4c803b",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "850fac8a_9f1f8ee0",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 711,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T08:30:31Z",
      "side": 1,
      "message": "lg2::error, same for the below logs",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "cf05f632_aced5684",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 711,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-09-17T16:56:51Z",
      "side": 1,
      "message": "Acknowledged",
      "parentUuid": "850fac8a_9f1f8ee0",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "41c9a126_68bf93ac",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 723,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T08:30:31Z",
      "side": 1,
      "message": "nit: this is just preference but i don\u0027t like having `std::exit` all over the code.\n\nIt messes with the symmetry of constructor/destructor, as some destructors will not be called.\n\nhttps://en.cppreference.com/w/cpp/utility/program/exit\n\nMy preference would be to pass some return value in error case and then `std::exit` in on place, or not `std::exit` at all and just return from main function.",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "691a6667_c07fc58d",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 723,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-09-17T16:56:51Z",
      "side": 1,
      "message": "std::exit and std::cerr were put in as extending the previous logic in this function. I\u0027m fine with moving logs over to lg2.\n\nThat said, if we have critical system resources that aren\u0027t being cleaned up by the OS on process exit, destructors won\u0027t save us in general and we likely have a design flaw. std::exit isn\u0027t the only way that this program can end without firing destructors.\n\nFrom a code design perspective, yes, returning from main is cleaner; from a \"are resources cleaned up\" perspective, if we\u0027re relying on destructors firing on process exit paths, things are kind of broken.",
      "parentUuid": "41c9a126_68bf93ac",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1ba99a0_07fc89ed",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 723,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T17:37:15Z",
      "side": 1,
      "message": "\u003e std::exit and std::cerr were put in as extending the previous logic in this function. I\u0027m fine with moving logs over to lg2.\n\nYes, usually implementing similar to the existing code is a good idea.\n\nBut the existing code here is not amazing so we may want to go a different route.\n\n### lg2\n\nFor the lg2, you can just also pick and choose from https://gerrit.openbmc.org/c/openbmc/entity-manager/+/83682 for whichever files/functions you consider in scope of your change (or just convert the entire file in a patch before/after this one).\n\n### local reasoning and `std::exit`\n\nregular functions usually return or throw something.\n\nIf we `std::exit` anywhere along the way then local reasoning is broken, because\n\nin function `a` we now need to consider the `std::exit` that happens in function `c` along the caller relationship `a -\u003e b -\u003e c`\n\nbecause any code after the call to `b` will not be run.\n\nAnd if local reasoning is broken, the code will become unmaintainable (IMO).\n\n### funny example of how EM uses destructors\n\n\u003e From a code design perspective, yes, returning from main is cleaner; from a \"are resources cleaned up\" perspective, if we\u0027re relying on destructors firing on process exit paths, things are kind of broken.\n\nhttps://github.com/openbmc/entity-manager/blob/fd939286bad96a52004925893ae5b98d6b67a623/src/entity_manager/perform_scan.cpp#L603\nthis is `scan::PerformScan::~PerformScan()`.\n\nIt\u0027s a destructor which either makes a shared_ptr (of another instance of itself) or calls a callback.\n\n### program portability and `std::exit`\n\nprograms using `std::exit` are hard to turn into libraries. Since control flow does not go back through the main function.\n\n### unit testing and `std::exit`\n\nIt\u0027s hard to test code using `std::exit` because the test will ... exit.\n\nSo it\u0027s not possible to do any assertions after such an exit has taken place.\n\nAlso not possible to run multiple tests in sequence in the same process.",
      "parentUuid": "691a6667_c07fc58d",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "80da1c5e_f34b1f42",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 723,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-09-17T18:30:18Z",
      "side": 1,
      "message": "we haven\u0027t changed any of the operating assumptions of this function, namely that if the config is malformed enough, we refuse to parse it, and if we don\u0027t have a proper config, we can\u0027t do anything well enough to move on with the process. Which, for config parsing, is generally a decent assumption IMO, separate from concerns about function design or which entity in the callgraph makes that decision.\n\nI understand your points about unit testing and local reasoning, and I generally agree with them. In its current form this function isn\u0027t unit testable in any way. Its hidden in a .cpp file, and relies on global variables as is.\n\nI don\u0027t see any of the code in this entire file as being a decent target for a separable library, there are much bigger fish to fry around that, i.e. that dbus logic is deeply intertwined with business logic.\n\nThis is a function that runs at startup, once, by design. If this was deep into a dbus driven callgraph, I would absolutely agree with you that this needs to be fixed.\n\nIf we want to refactor this function and make it unit testable, etc, its a decent target for that IMO. That should be a separate commit from a feature add, however.",
      "parentUuid": "a1ba99a0_07fc89ed",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ca52e597_533d48bd",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 723,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T18:55:34Z",
      "side": 1,
      "message": "You can easily reduce the number of `std::exit` being added here by extracting your address block list parsing code into a separate function like `loadAddressBlockList`.\n\nThen just `std::exit` once in `loadBlocklist`. in case `loadAddressBlockList` fails.\n\nAs of this patchset, the function very long anyways.",
      "parentUuid": "80da1c5e_f34b1f42",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b4d87d9b_3a854413",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1486,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T08:30:31Z",
      "side": 1,
      "message": "Do you think it could work to create `class FRUDevice` or similar so functions like `rescanOneBus` can be member functions and avoid passing this parameter through all these functions.\n\nOr is it not possible due to some other concern.",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f0342cda_7a9b8794",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1486,
      "author": {
        "id": 1002504
      },
      "writtenOn": "2025-09-17T16:56:51Z",
      "side": 1,
      "message": "Its certainly possible, but would be a relatively large refactor of the code base, which I\u0027m not opposed to but I don\u0027t want to tie that refactor to this change. There\u0027s a number of places where having an object (or more) would make some of this easier, especially around passing around the contents of the FRU and this kind of bus level metadata. Specifically on rescanOneBus and its ilk, I don\u0027t think a FruDevice should be responsible for that (rescanOneBus \u0026 rescanBusses should probably return constructed FruDevices), but thats the kind of bikeshedding we can do in a different review.",
      "parentUuid": "b4d87d9b_3a854413",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95be6518_e1a673d1",
        "filename": "src/fru_device/fru_device.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1486,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-17T17:37:15Z",
      "side": 1,
      "message": "\u003e Specifically on rescanOneBus and its ilk, I don\u0027t think a FruDevice should be responsible for that\n\n\u003e but thats the kind of bikeshedding we can do in a different review.\n\nOk, if there is no obviously right class definition then i will close the comment. You will know best since you recently edited the code.",
      "parentUuid": "f0342cda_7a9b8794",
      "revId": "f0bb21e6e0837cbfd3829f2e066b65af0b6b6925",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}