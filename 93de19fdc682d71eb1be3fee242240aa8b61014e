{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "b94efd6b_687651c3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-07-22T08:30:28Z",
      "side": 1,
      "message": "Do you know why `fdio.next()` is triggered?\n\nWe are only requesting edge events, right?\n\nSo i am wondering what is happening for `fdio.next()` to pass.\n\n```\n        gpiod::line_request lineConfig;\n        lineConfig.consumer \u003d \"gpio-presence\";\n        lineConfig.request_type \u003d gpiod::line_request::EVENT_BOTH_EDGES |\n                                  gpiod::line_request::DIRECTION_INPUT;\n\n        int lineFd \u003d -1; \n        try \n        {   \n            gpioLines[gpioName].request(lineConfig);\n\n            lineFd \u003d gpioLines[gpioName].event_get_fd();\n        }\n        catch (std::exception\u0026 e)\n        {\n            error(\"{ERROR}\", \"ERROR\", e);\n            return;\n        }\n        if (lineFd \u003c 0)\n        {\n            error(\"could not get event fd for gpio \u0027{NAME}\u0027\", \"NAME\", gpioName);\n            return;\n        }\n\n        if (!fdios.contains(gpioName))\n        {\n            fdios.insert(\n                {gpioName,\n                 std::make_unique\u003csdbusplus::async::fdio\u003e(ctx, lineFd)});\n```",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5df11ba1_3608025b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1002520
      },
      "writtenOn": "2025-07-23T03:10:38Z",
      "side": 1,
      "message": "sdbusplus::async::fdio lets us handle sd_event in an async way, but that also brings a race condition.\n\nFrom the sd-event man page(https://man7.org/linux/man-pages/man3/sd-event.3.html), we can see this behavior:\n\n“In each event loop iteration a single event source is dispatched. Each time an event source is dispatched, the kernel is polled for new events before the next event source is dispatched.”\n\nHere’s what happens:\nWhen sd_event sees that a FD is readable, it calls handleEvent(), which resumes our fdio.next() coroutine. But before we call event_read(), sd_event performs another poll in the same loop. If the FD is still marked readable, it triggers the handler again.\n\nAt this point, a second coroutine starts — but the event queue is already empty because the first one hasn’t consumed the event yet. As a result, the second coroutine blocks on event_read().\n\nIf you insert a short delay before event_read(), you’ll see the issue more often. This helps confirm the root cause.",
      "parentUuid": "b94efd6b_687651c3",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2efdf37b_4a9f2f92",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-07-24T01:01:03Z",
      "side": 1,
      "message": "\u003e sdbusplus::async::fdio lets us handle sd_event in an async way, but that also brings a race condition.\n\u003e \n\u003e From the sd-event man page(https://man7.org/linux/man-pages/man3/sd-event.3.html), we can see this behavior:\n\u003e \n\u003e “In each event loop iteration a single event source is dispatched. Each time an event source is dispatched, the kernel is polled for new events before the next event source is dispatched.”\n\u003e \n\u003e Here’s what happens:\n\u003e When sd_event sees that a FD is readable, it calls handleEvent(), which resumes our fdio.next() coroutine. But before we call event_read(), sd_event performs another poll in the same loop. If the FD is still marked readable, it triggers the handler again.\n\n\nThe complete() function (which gets called from event handler) gets de-registered before fdio-\u003enext() resumes. \n\n\u003e \n\u003e At this point, a second coroutine starts — but the event queue is already empty because the first one hasn’t consumed the event yet. As a result, the second coroutine blocks on event_read().\n\nSpecifically on what you mentioned here - How the event queue is empty if first one (run iteration after fdio-\u003enext()) hasn\u0027t been consumed yet?\n\nAre you saying the handler was still being invoked even after last event_read() which made the fdio-\u003enext() in next iteration to proceed further?\n\n\u003e \n\u003e If you insert a short delay before event_read(), you’ll see the issue more often. This helps confirm the root cause.",
      "parentUuid": "5df11ba1_3608025b",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a5989f9f_c5f82963",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1002520
      },
      "writtenOn": "2025-07-24T01:47:32Z",
      "side": 1,
      "message": "\u003e The complete() function (which gets called from event handler) gets de-registered before fdio-\u003enext() resumes.\n\n\u003e Are you saying the handler was still being invoked even after last event_read() which made the fdio-\u003enext() in next iteration to proceed further?\n\n\nWhat you mentioned is exactly the issue. The handler was invoked and returned immediately, but the event hadn’t been consumed yet. sd_event polled the FD again in the same iteration and saw it was still readable, so it marked it with EPOLLIN again. \nOn the next iteration, sd_event dispatched this event, causing fdio-\u003enext() to resume another coroutine. But by that time, the first coroutine had already consumed the event, so event_read() in the second coroutine found nothing and blocked.",
      "parentUuid": "2efdf37b_4a9f2f92",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "09e35dc7_38bc709b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 11,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-07-29T16:39:48Z",
      "side": 1,
      "message": "Sure, thanks for debugging this.",
      "parentUuid": "a5989f9f_c5f82963",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "881305c8_a100f6eb",
        "filename": "src/gpio-presence/gpio_presence_manager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 248,
      "author": {
        "id": 1001758
      },
      "writtenOn": "2025-07-29T16:37:28Z",
      "side": 1,
      "message": "Lets rephrase this as -\n\nevent_read() does not clear the EPOLLIN flag immediately; it is cleared during the subsequent epoll check. Therefore, call event_wait with a zero timeout to ensure that event_read() is only invoked when an event is available, preventing it from blocking.",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eb73cd03_fb4617f3",
        "filename": "src/gpio-presence/gpio_presence_manager.cpp",
        "patchSetId": 1
      },
      "lineNbr": 248,
      "author": {
        "id": 1002520
      },
      "writtenOn": "2025-07-30T12:05:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "881305c8_a100f6eb",
      "revId": "93de19fdc682d71eb1be3fee242240aa8b61014e",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}