{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4aa8f2a4_cc38c15a",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-08-29T11:28:26Z",
      "side": 1,
      "message": "If this upstream board must be a Chassis or Board, and assocName must be contained_by or powering, should the assoc be added to downstream instead?",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1664eccc_59fffabc",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-08-29T11:39:48Z",
      "side": 1,
      "message": "Thanks for looking into this patch ðŸ˜Š\n\nThe testcases have some restriction on which path the association definitions must go.\n\nI added a comment a few lines above that the association definition happens from one side in the old code and it\u0027s not necessarily consistent.\n\nFrom my perspective i do not understand what `upstream` and `downstream` is about,\n\nWhen looking at `containing` it is vaguely clear that the `containing` entity is the upstream but i am not sure what the benefit is in the distinction.\n\n\nTheoretically we can define the association definition from either side or even from both sides.\n\nThere should not be any difference in the ObjectMapper output if we define the association from a different side.\n\nBut i wrote it this way to pass the unit tests without changes.",
      "parentUuid": "4aa8f2a4_cc38c15a",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45114d63_86184065",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2025-09-05T15:21:35Z",
      "side": 1,
      "message": "@chaul@amperecomputing.com Was your concern because of your previous fix https://github.com/openbmc/entity-manager/commit/a454b30738429365e4822db9f2baebd697bdd1ce?",
      "parentUuid": "1664eccc_59fffabc",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b6b1e126_eb6556e5",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-09-09T04:17:00Z",
      "side": 1,
      "message": "Hi @spinler@us.ibm.com, it\u0027s not quite because of my commit.\n\nI was just looking at it from the old implementation point of view.\n\nIf `fillAssocsForPortId` only accepts Chassis or Board (L127) and does not accept assocName of `containing` or `powered_by` (L146), then assocName is either `contained_by` or `powering`. For a `powering` assocName, it shouldn\u0027t be attached to a Chassis/Board, right?",
      "parentUuid": "45114d63_86184065",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0490dfae_0e8f8981",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1001712
      },
      "writtenOn": "2025-09-09T12:27:41Z",
      "side": 1,
      "message": "\u003e For a powering assocName, it shouldn\u0027t be attached to a Chassis/Board, right?\n\nThere is a testcase for  `https://github.com/openbmc/entity-manager/blob/86780aa23e01a4215314f067b139d01fa0b320d0/test/test_topology.cpp#L168`\n\nwhich has \n```\nEXPECT_TRUE(assocs[subchassisPath].contains(powerAssoc));\n```\nand\n```\nconst Association powerAssoc \u003d\n    std::make_tuple(\"powering\", \"powered_by\", superchassisPath);\n```\n\nso the subchassis is powering the superchassis.\n\nDo you think it would help if i tried to create some testcases involving\nconfig with Type `PowerSupply` and `powering` association if that\u0027s possible.\n\nSo we do not break anything that\u0027s currently possible to configure there.",
      "parentUuid": "b6b1e126_eb6556e5",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "afd3f74d_02b92978",
        "filename": "src/entity_manager/topology.cpp",
        "patchSetId": 2
      },
      "lineNbr": 151,
      "author": {
        "id": 1001526
      },
      "writtenOn": "2025-09-10T08:32:03Z",
      "side": 1,
      "message": "I understand it now.\n\nIf assocName is \"powering\", then the upstream path passed into `fillAssocForPortId` is the board with an power port. However, this is skipping board types that are not Chassis or Board, so if the power port is configured in a board of type PowerSupply, then the assoc will be skipped.\n\nThe test case passed because the subchassis is defined as \"Chassis\" type.\n\nAm I missing something here?",
      "parentUuid": "0490dfae_0e8f8981",
      "revId": "5cd44d2e5c2d100b0087f68a310826e6a41e0609",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}