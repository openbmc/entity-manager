{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "54ef35d6_b30f0ce4",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2024-10-24T20:32:19Z",
      "side": 1,
      "message": "Note: All Async API examples I\u0027ve seen in SDBusPlus use\n\n\u003ectx.spawn( -\u003e sdbusplus::async::task\u003c\u003e {\n\u003e    ctx.request_name(reqDBusName);\n\u003e    co_return;\n\u003e}(ctx));\n\n\nhttps://github.com/openbmc/sdbusplus/blob/578b9733d30bb03015715932e9f64d11416655ca/example/coroutine-example.cpp#L101\n\nhttps://github.com/openbmc/sdbusplus/blob/578b9733d30bb03015715932e9f64d11416655ca/example/calculator-client.cpp#L69\n\nhttps://github.com/openbmc/sdbusplus/blob/578b9733d30bb03015715932e9f64d11416655ca/example/calculator-aserver.cpp#L67\n\nbut when Entity-Manager\u0027s clang-tidy rule \"readability-static-accessed-through-instance\" (with warning as error flag set) hits this line, it throws \u0027bad\u0027 suggestions -- seemingly no matter how simple the call being passed to \u0027spawn\u0027\n\nrelevant here CI tool output (and discussion) here:\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75353/comment/57743120_586df2a2/\n\nThe \u0027original\u0027 code works if //NOLINTNEXTLINE(readability-static-accessed-through-instance) is specified, but I have the impression we don\u0027t want to do that if it can be avoided.",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ecb4113a_23c82734",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1000008
      },
      "writtenOn": "2024-10-24T21:08:16Z",
      "side": 1,
      "message": "My vote would be the NOLINT direction.  Patrick had found the clang-tidy issue where they have plans to handle it better in the next version so hopefully it\u0027d just be temporary anyway.",
      "parentUuid": "54ef35d6_b30f0ce4",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fd0bba2_62619323",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-10-25T00:19:30Z",
      "side": 1,
      "message": "Why do we have threads and mutexes? This seems too complex. I\u0027d much rather we read the procfs devicetree attributes into stack-local variables before doing any DBus-related work, and drop the threads and the mutexes.",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5fcbb7c3_65438881",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2024-10-25T14:08:36Z",
      "side": 1,
      "message": "I experimented with std::thread partially as \n\nA) potential workaround for erroneous CI tool output surrounding Async API .spawn calls (discussion on that here: https://gerrit.openbmc.org/c/openbmc/entity-manager/+/75353/comment/57743120_586df2a2/ --  but now it sounds like we\u0027re leaning towards rolling back this bit back to using Async API\u0027s context.spawn + a //NOLINT tag)\n\nB) in response to a comment Ed T made about the MachineContext populate operation:\n\u003eThis is doing a blocking IO call in the async reactor, which will deadlock all other calls if this node takes a long time to reply. In asio we have uring based file readers, or should we do this in its own thread so we don\u0027t block dbus?\n\nhttps://gerrit.openbmc.org/c/openbmc/entity-manager/+/75349/comment/dcde11bc_365a072c/\n\nI have not yet dug into the uring file reader option since it seemed like using std::thread might solve a few things at a once-- but I\u0027ll go ahead and take a closer look into the uring readers option next.",
      "parentUuid": "9fd0bba2_62619323",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d21a877_02e0fe11",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1000009
      },
      "writtenOn": "2024-10-25T21:31:59Z",
      "side": 1,
      "message": "I think explicit consideration of io_uring is over-complicating it as well.\n\nAll we need to do is:\n\n1. do simple blocking reads of the procfs files into local variables\n2. setup and run the async dbus stuff, passing the local variables in as the data for the machine context object\n\nin that order.\n\nThe blocking reads aren\u0027t even going to block, the data comes straight of memory, so IMO the concern seems a bit overblown. However the approach above removes the problem.\n\nIf necessary, a `//NOLINT` is preferable than invoking the complexity of threads and mutexes.",
      "parentUuid": "5fcbb7c3_65438881",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "daaedbb0_87daa0e6",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2024-10-26T03:26:01Z",
      "side": 1,
      "message": "\u003edo simple blocking reads of the procfs files into local variables\nsetup and run the async dbus stuff, passing the local variables in as the data for the machine context object\n\nPatrick may have more insight into how Async API works behind the scenes here and may correct me -- but I have the impression the steps you\u0027ve enumerated are more-or-less the default behavior when going through SDBusPlus Async API -- if I hadn\u0027t added the thread-related code.\n\nMy current understanding of the process seen in lines 12 - 14 here is:\nMachineContext object is instantiated. The constructor does blocking reads (without the std:::thread stuff; that\u0027s new), and uses the results to populate properties that were inherited from an SDBusPlus Async API version of Inventory::Asset. A reference to this instance is saved to \u0027async::context ctx.\u0027 \n\nI *think* the spawn call just cues up anything that needs to be done asynchronously at this point, then when ctx.run() is called, the spawn function fires off, then the MachineContext object is consumed and a d-bus bus is plumbed out based on that.\n\nUp until ctx.run() is called, I believe nothing here interacts with d-bus. Once ctx.run() is called, changes to the MachineContext object do not appear to be reflected to the associated d-bus property after that point.\n\nIf things really that simple with the Async API, it seems like I *might* be able to just remove the std::thread stuff, put the ctx.spawn with //NOLINT back into the dt_vpd_parser.cpp and expect things to be \u0027good as-is\u0027.",
      "parentUuid": "2d21a877_02e0fe11",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68442880_17d93880",
        "filename": "src/dt_vpd_parser.cpp",
        "patchSetId": 3
      },
      "lineNbr": 14,
      "author": {
        "id": 1001354
      },
      "writtenOn": "2024-10-26T15:45:15Z",
      "side": 1,
      "message": "I\u0027ve gone ahead and reverted the thread and mutex additions for now.",
      "parentUuid": "daaedbb0_87daa0e6",
      "revId": "31c5d474ca940444236d4166110382a0229b95d1",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}