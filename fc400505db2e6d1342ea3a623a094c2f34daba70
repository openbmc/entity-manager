{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f27055c3_e9c75764",
        "filename": "include/FruUtils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 1000265
      },
      "writtenOn": "2022-03-30T12:44:58Z",
      "side": 1,
      "message": "Apologies for having been misleading in prior discussions.\n\nI just read up about the difference between size_t and off_t: \"size_t is part of the C++ (and C) standards, and refers to the type of a sizeof expression. off_t is defined by the Posix standard, and refers to the size of a file.\" and \"off_t is signed whereas size_t is unsigned\" (from https://stackoverflow.com/questions/10634629/what-are-the-usage-differences-between-size-t-and-off-t).\n\nAssuming this is true, I wonder if using size_t for both \"address\" and \"offset\" is really what we should be using? I noticed that there are a few \"uint8_t address\" declarations, which I assume relate to the i2c-device-address, but I\u0027d say that all declarions of \"uint16_t address\" and \"uint16_t offset\" should really be size_t.\n\nThoughts?",
      "range": {
        "startLine": 87,
        "startChar": 64,
        "endLine": 87,
        "endChar": 69
      },
      "revId": "fc400505db2e6d1342ea3a623a094c2f34daba70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c73b9a1d_fdf13705",
        "filename": "include/FruUtils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-03-31T09:19:21Z",
      "side": 1,
      "message": "\u003e I wonder if using size_t for both \"address\" and \"offset\" is really what we should be using?\n\nYeah, the signedness of off_t is probably unnecessary for what we\u0027re likely to be doing with it, but given that it\u0027s got plenty of range for FRU EEPROM sized things I don\u0027t think it\u0027ll ever be a problem, and seems preferable to me in terms of communicating intent.\n\n\u003e I noticed that there are a few \"uint8_t address\" declarations, which I assume relate to the i2c-device-address, but I\u0027d say that all declarions of \"uint16_t address\" and \"uint16_t offset\" should really be size_t.\n\nAfter this patch I don\u0027t see any instances of `uint16_t offset` remaining, and I\u0027m pretty sure that all the remaining `uint16_t address` instances are I2C bus addresses -- I2C addresses are typically 8 bits (or 7 really I suppose) but can in some cases be 10 bits, so uint16_t seems like an appropriate type for them (and arguably the `uint8_t address` instances should be converted to it, but I\u0027ll leave that for another patchset).",
      "parentUuid": "f27055c3_e9c75764",
      "range": {
        "startLine": 87,
        "startChar": 64,
        "endLine": 87,
        "endChar": 69
      },
      "revId": "fc400505db2e6d1342ea3a623a094c2f34daba70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0869e397_1ca9276f",
        "filename": "include/FruUtils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-13T19:26:18Z",
      "side": 1,
      "message": "Rule of thumb is:\n\nIs this going to be used to index into an stl container (vector, array) or buffer?  Use size_t\n\nIs this going to be used on a hardware interface that has a hard limit or signeness imposed by the standard (ie, i2c only has 7/11 bits of address fields), use the type that best fits the case, or match the type that the underlying sysfs API uses.\n\nIn this case, address is limited to 11 unsigned bits by the standard, so uint16_t makes sense there.  offset is almost certainly going to be used to directly index or slice into some kind of buffer (ie buffer[offset]) so it should probably be size_t.\n\n\nWith the above said, we\u0027re wildly inconsistent here.   I do think off_t is the wrong thing to be using when we\u0027re not operating on a file.\n\n\n\u003eYeah, the signedness of off_t is probably unnecessary for what we\u0027re likely to be doing with it, but given that it\u0027s got plenty of range for FRU EEPROM sized things I don\u0027t think it\u0027ll ever be a problem, and seems preferable to me in terms of communicating intent.\n\nThe problem becomes when you try to use it on a buffer, now every time you want to do;\n\nbuffer[myOffT], you have to do two range checks, one for \u003c 0 and one for \u003e buffer.size(), and with the compiler options, you have to do a static_cast\u003csize_t\u003e(myOffT) to make the compiler happy with you.  That ends up being kinda messy.",
      "parentUuid": "c73b9a1d_fdf13705",
      "range": {
        "startLine": 87,
        "startChar": 64,
        "endLine": 87,
        "endChar": 69
      },
      "revId": "fc400505db2e6d1342ea3a623a094c2f34daba70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "db8a719a_d21e5f2b",
        "filename": "include/FruUtils.hpp",
        "patchSetId": 3
      },
      "lineNbr": 87,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-04-13T19:27:48Z",
      "side": 1,
      "message": "Oh.... except we are operating on a file in some (most) cases.......   off_t is probably fine then?",
      "parentUuid": "0869e397_1ca9276f",
      "range": {
        "startLine": 87,
        "startChar": 64,
        "endLine": 87,
        "endChar": 69
      },
      "revId": "fc400505db2e6d1342ea3a623a094c2f34daba70",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}