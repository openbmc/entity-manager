{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "0b8677e4_02ce4580",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000559
      },
      "writtenOn": "2022-08-10T16:44:38Z",
      "side": 1,
      "message": "LGTM",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "5186047e_aac5cce2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:45:04Z",
      "side": 1,
      "message": "Adding Zev, who\u0027s looking at porting this stuff out of EM.  Giving him some time to review.",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "535d3726_3f3c15a9",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T09:53:03Z",
      "side": 1,
      "message": "Thanks Ed, hadn\u0027t been aware of this patch.",
      "parentUuid": "5186047e_aac5cce2",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b184cea5_13ceeb2a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2022-08-15T15:54:42Z",
      "side": 1,
      "message": "My observations.",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a1a2e6b_7381ab91",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2022-08-15T16:21:37Z",
      "side": 1,
      "message": "I\u0027ll perform the manual rebase and submit it.",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "eceb9c72_c875ea5f",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:45:04Z",
      "side": 1,
      "message": "This is sooooo much better.",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4951ec8e_959114ef",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 47,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T09:53:03Z",
      "side": 1,
      "message": "Agreed, exportTemplates is a lot more self-explanatory this way, definite clarity win.",
      "parentUuid": "eceb9c72_c875ea5f",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c5506cb9_31272a7c",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-11T04:45:04Z",
      "side": 1,
      "message": "seems unlikely that a compiler would start with true, but should we do \u003d false here just to be explicit and not have technical UB?",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 14
      },
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f3be789_62143100",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T09:53:03Z",
      "side": 1,
      "message": "The potential UB being that the value for hasHWMonDir would then be \"true + 1\", exceeding the range of the bool type assigned for the enum, or something more subtle?\n\nIn any case, while I\u0027m not a C++ expert, C at least guarantees that in the absence of an explicitly-provided value enums will start from zero, and I\u0027d be fairly surprised if C++ diverged from that...",
      "parentUuid": "c5506cb9_31272a7c",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 14
      },
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b9015f6a_ee21a50a",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-15T14:42:42Z",
      "side": 1,
      "message": "\u003e The potential UB being that the value for hasHWMonDir would then be \"true + 1\", exceeding the range of the bool type assigned for the enum, or something more subtle?\n\u003e \n\u003e In any case, while I\u0027m not a C++ expert, C at least guarantees that in the absence of an explicitly-provided value enums will start from zero, and I\u0027d be fairly surprised if C++ diverged from that...\n\n\nFound this in the standard:\n\"If the first enumerator has no initializer, the value of the corresponding constant is zero. An enumerator-definition without an initializer gives the enumerator the value obtained by increasing the value of the previous enumerator by one.\"\n\nTIL.\n\nWith that said.....  As I look at this again, there\u0027s nowhere it\u0027s used as a static_cast\u003cbool\u003e so it should be fine as-written.  I think the ideal case would be to remove the \" : bool\" from the class, and just let the compiler pick the type, but that\u0027s not that important.",
      "parentUuid": "8f3be789_62143100",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 14
      },
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "36a199ed_eecb1166",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2022-08-15T15:54:42Z",
      "side": 1,
      "message": "One of my significant problems with programming in C++, is determining what kind of data the code is working on. Any time I can be explicit about the data type I\u0027m going to apply that information for the unfortunate soul following after me (which may be me for all I know). I understand \"auto\" helps the compiler generate code that is more likely to follow C++ rules, and in theory be correct. It doesn\u0027t, OTOH, help the programmer determine what kind of \"thing\" \"var\" refers. I find this especially frustrating with async D-Bus calls. Thus if I can provide even a Burma Shave signpost guidance I\u0027m going to favor doing so.",
      "parentUuid": "b9015f6a_ee21a50a",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 14
      },
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7403a8d6_7e01f0a4",
        "filename": "include/devices.hpp",
        "patchSetId": 2
      },
      "lineNbr": 50,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-15T16:17:46Z",
      "side": 1,
      "message": "As a preface, my opinion here is very weak, and what you have is fine.\n\nTo the above, I would argue that the enumeration values themselves provide the complete information on what this is intended to be used for.  inheriting from bool implies that there is a case where the user might do a static_cast\u003cbool\u003e() to get a boolean value out of the enum, which in this case they shouldn\u0027t do.\n\nAgain, what\u0027s there is fine if you don\u0027t want to change it.",
      "parentUuid": "36a199ed_eecb1166",
      "range": {
        "startLine": 50,
        "startChar": 4,
        "endLine": 50,
        "endChar": 14
      },
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "25636991_57738f4e",
        "filename": "src/overlay.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-08-11T09:53:03Z",
      "side": 1,
      "message": "This part (and similar changes in the callee functions) I\u0027m slightly less enthused about -- the variable name still sort of sounds like it\u0027s a boolean, but it no longer really is, or at least can\u0027t (comfortably, IMO) be used as one even if that\u0027s the underlying type of the enum.\n\nIn the exportTemplates map the booleans do get sorta lost amongst all the other stuff and end up a lot less readable and a lot more error-prone, so I do think this is a good change to make there.  I don\u0027t think the existing overlay.cpp code has any of the same clarity problems though, so propagating the enum through these paths seems like added verbosity for slightly less overall readability IMO.  (Perhaps this is the same thing Zhikui commented on previously?)\n\nOne possibility that occurs to me would be to expand the enum to something like\n\n```\nenum DeviceKind\n{\n  hwmon,\n  iio,\n  mux,\n  eeprom,\n  gpio,\n};\n```\n\nand then just pass that through and have the code that cares about it do `if (kind \u003d\u003d DeviceKind::hwmon) path /\u003d \"hwmon\"`.  Arguably overkill if there\u0027s currently really only one kind we ultimately care about though...I dunno.\n\nAnyway, with all that said it\u0027s not a strenuous objection, so I\u0027ll leave it up to the author \u0026 maintainers.",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9c78148b_92d63c9d",
        "filename": "src/overlay.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2022-08-15T15:54:42Z",
      "side": 1,
      "message": "I gave this idea some consideration prior to submitting the first commit. My main reason for not doing something like this is there has been no evidence of a similar failure in another device driver. \n\nDoing what you suggest is additional work that appears to have limited payoff. As the author I am obligated to iterate \u003e70 template entries and categorize the type of each only for the work to devolve to \"HWMon\"/\"noHWMON\". I\u0027m not enthusiastic about expending time to do that.\n\nThe enum you suggest is a little weird. What kind of device is a \"hwmon\"? Is it better to enumerate on device type, or sensor initialization model? Presently it\u0027s the model. The device type, at this stage, only cares about temperature devices.\nPerhaps this model works:\nenum sensorInitRequirment {\n  norequirement,            // mux, eeprom, gpio, etc...\n  temperatureWithHWMon,     // the one we need to retry\n  temperatureWithoutHWMon,  // author considered init rqmt\n};\n\nThis covers the current situation without undue burden in updating the Export table. It still leaves room for handling undiscovered initialization problems.",
      "parentUuid": "25636991_57738f4e",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "af00789d_635d2f20",
        "filename": "src/overlay.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-08-15T16:17:46Z",
      "side": 1,
      "message": "\u003e enum DeviceKind\n\u003e {\n\u003e   hwmon,\n\u003e   iio,\n\u003e   mux,\n\u003e   eeprom,\n\u003e   gpio,\n\u003e };\n\nI like this as a concept, but in the efforts to keep THIS patch small, self contained, and an incremental improvement, lets push the above to a later patchset.\n\n\u003e I gave this idea some consideration prior to submitting the first commit. My main reason for not doing something like this is there has been no evidence of a similar failure in another device driver. \n\u003e \n\u003e Doing what you suggest is additional work that appears to have limited payoff. As the author I am obligated to iterate \u003e70 template entries and categorize the type of each only for the work to devolve to \"HWMon\"/\"noHWMON\". I\u0027m not enthusiastic about expending time to do that.\n\nSure.  Considering the old code didn\u0027t do that, it seems reasonable, although I do think in the end we will need something closer to what Zev is proposing, but I don\u0027t think anyone is requiring that you be the one to do it.\n\n\u003e \n\u003e The enum you suggest is a little weird. What kind of device is a \"hwmon\"? Is it better to enumerate on device type, or sensor initialization model? Presently it\u0027s the model. The device type, at this stage, only cares about temperature devices.\n\u003e Perhaps this model works:\n\u003e enum sensorInitRequirment {\n\u003e   norequirement,            // mux, eeprom, gpio, etc...\n\u003e   temperatureWithHWMon,     // the one we need to retry\n\u003e   temperatureWithoutHWMon,  // author considered init rqmt\n\u003e };\n\u003e \n\u003e This covers the current situation without undue burden in updating the Export table. It still leaves room for handling undiscovered initialization problems.\n\n\n\nAs written, IMO, this patchset has hit the barrier to merge in that it\u0027s:\n1. Incrementally better\n2. Self contained in that it follow the \"spirit\" of the old code (which was a bool)\n3. Tested.\n4. Doesn\u0027t actively make the above suggestion more difficult to execute on in the future.\n\nI\u0027m happy to discuss other possible changes to this enum either in other patches, the mailing list, or on discord, and I definitely think there\u0027s a lot of improvement to happen there, but in terms of this patch, I think we\u0027ve hit escape velocity.",
      "parentUuid": "9c78148b_92d63c9d",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "235a8bb2_12578a4c",
        "filename": "src/overlay.cpp",
        "patchSetId": 2
      },
      "lineNbr": 239,
      "author": {
        "id": 1000278
      },
      "writtenOn": "2022-08-25T18:34:06Z",
      "side": 1,
      "message": "If there are no other objections, I\u0027d like this to merge.",
      "parentUuid": "af00789d_635d2f20",
      "revId": "6650e6df3bb8d322885ec3e8b818f2c53860916c",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}