{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "a8d0eae7_f8a8adf2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-15T21:15:08Z",
      "side": 1,
      "message": "HAH, James and I argued about this exactly thing in code review when he first did it.  Only took 4 years for me to be vindicated ðŸ˜Š\n\nThis is on my list to review (haven\u0027t done yet).  Given the possibilities of race conditions, testing this is going to be fun, but we\u0027ll get that figured out.",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c8c57ab_e053f476",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2022-02-15T22:20:20Z",
      "side": 1,
      "message": "B",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d522a96b_4181fac8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2022-02-15T22:20:20Z",
      "side": 1,
      "message": "Yeah, async behavior is not obvious in these these case. When I initially read this code, I thought getBusFRUs would return and let the async thread keep running in the background (which would be bad). But then I tested out a simple example and saw that ~future() waits for the task to exit (and confirmed this behavior is documented on cppreference).\n\nI\u0027m just learning about fru-device and noticed this weird code, so I welcome any suggestions for testing it.",
      "parentUuid": "a8d0eae7_f8a8adf2",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc53d64d_1a7d96f5",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-08T15:45:23Z",
      "side": 1,
      "message": "I\u0027d probably start by reworking a board to lock up the i2c bus (grounding out a clock pin should be enough).",
      "parentUuid": "d522a96b_4181fac8",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "571ec4fa_b4306fe6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-08T15:45:23Z",
      "side": 1,
      "message": "right, but keep in mind that ~future isn\u0027t called until this leaves scope, and I believe the timer executes as part of the future.  Ideally this would all move to asio stuff to be more \"normal\"",
      "parentUuid": "d522a96b_4181fac8",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a543550b_4b9486ca",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1000900
      },
      "writtenOn": "2022-06-10T01:08:44Z",
      "side": 1,
      "message": "After looking at this more, I can see that the existing code does work because we are able to abort an hung ioctl() call by closing the fd when the future times out. There is no simple way to achieve the same thing without using multiple threads as the future/async is doing. What I considered:\n\n1. This change. Doesn\u0027t work b/c it doesn\u0027t abort the ioctl()\n2. ASIO-based solutions as suggested by Ed. We need to use ioctl() so async_read-type solutions won\u0027t help. Using a timer to close the fd doesn\u0027t work while we\u0027re stuck in the kernel.\n3. Using the I2C_TIMEOUT ioctl() beforehand to prevent things from hanging for so long. This may work well but it\u0027s a global operation on the i2c adapter properties so I\u0027m wary of doing it just for fru-device.\n\nSo I\u0027m going to abandon this change.",
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67b9b8c7_74e7cbfb",
        "filename": "src/FruDevice.cpp",
        "patchSetId": 2
      },
      "lineNbr": 62,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-08T15:45:23Z",
      "side": 1,
      "message": "Nit, if you\u0027re declaring the type anyway, could you just do\n\nconstexpr std::chrono::seconds busTimeout(5);\n\nand avoid auto entirely?",
      "range": {
        "startLine": 62,
        "startChar": 0,
        "endLine": 62,
        "endChar": 52
      },
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4c6daf89_4eeee88f",
        "filename": "src/FruDevice.cpp",
        "patchSetId": 2
      },
      "lineNbr": 386,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-03-08T15:45:23Z",
      "side": 1,
      "message": "For a timer, I don\u0027t think this works.  My understanding was that when this was written, the call on line 409 would block, essentially forever./  The ideal way would be to set up a boost::asio::steady_timer instance to close the FD if needed.  Even better than that would be reworking it so that we do non-blocking async_read calls using boost::asio::random_access_file, and then in the timer just call cancel() in the case of the timer expiring.",
      "range": {
        "startLine": 386,
        "startChar": 0,
        "endLine": 386,
        "endChar": 57
      },
      "revId": "c734a6232f3c02c60f922b54db2ea2982df5af8a",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}