{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "be92ff1a_7fcdba94",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This being the case, how do you know you got the format right?",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 11,
        "endChar": 57
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f07246ef_06e22b82",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "There\u0027s a LinkedIn code dump that includes some code that supports the format; I grabbed the field order \u0026 size constants from here: https://github.com/linkedin/o19-bmc-firmware/blob/99678a156fd8d10b74793fb9c7b38408aa8cbe59/meta-openbmc/meta-linkedin/recipes-utils/linkedin-eeprom/files/lib/linkedin_eeprom.h",
      "parentUuid": "be92ff1a_7fcdba94",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 11,
        "endChar": 57
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2bb8c46c_c4331c2c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-14T18:45:33Z",
      "side": 1,
      "message": "This is great detail, and should be in your commit message.",
      "parentUuid": "f07246ef_06e22b82",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 11,
        "endChar": 57
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b3ef36be_8450eb04",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 11,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-15T00:51:21Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2bb8c46c_c4331c2c",
      "range": {
        "startLine": 10,
        "startChar": 39,
        "endLine": 11,
        "endChar": 57
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7ecf2985_e13b0980",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-12T01:00:43Z",
      "side": 1,
      "message": "Ed, I\u0027m currently looking at how to generalize this to more cleanly support multiple formats in an extensible, efficient way.\n\nThe rough idea I\u0027ve got at the moment (no real implementation work yet) is to have a set of supported formats (IPMI, Tyan, LI1902, perhaps JEDEC SPD in the future) each with a \"probe\" or matching function of some sort to answer the question \"does this EEPROM look like that format\".  I think that should address (at least part of) the extensibility requirement, but there\u0027s still the question of efficiency.\n\nThe various format matchers will presumably each have their own little section of the EEPROM they\u0027ll need to inspect, some of which will be at the same offset (e.g. IPMI and LI1902 both being at the start), but some may need to look elsewhere (e.g. TYAN checks at offset zero and then has to read more at offset 0x6000).  To support that in full generality (matchers wanting to look at arbitrary locations) we could certainly let each of them issue their own reads, but then we\u0027d be back in duplicated-I/O territory for the ones that do overlap as you pointed out here: https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/49341/comment/37c6bc0d_d0c4382b/\n\nSo to avoid that, we could introduce some little cache abstraction to store and regurgitate whatever bytes have already been read by an earlier matcher, perhaps as an offset:data map at some fixed granularity (blocks of 16 or 32 bytes or something, say).\n\nI\u0027m not opposed to implementing that and can go ahead with it if needed, but it\u0027s slightly more added complexity than I had initially been expecting this to incur.  Do you have any thoughts on the appropriateness of that, or any alternative approaches to consider?",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "67eeeef1_59102aa3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-12T01:10:01Z",
      "side": 1,
      "message": "Also, as I\u0027m looking at the codebase and considering the degree of restructuring of existing code this may end up involving...what would you think of a Rust reimplementation of fru-device?  (Mostly kidding...but maybe like 40% serious.)",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "32ce2779_c003e84d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-12T01:27:33Z",
      "side": 1,
      "message": "I suppose one alternate possibility would be to unconditionally read in the first N bytes and pass that buffer to each matcher on the expectation that many/most of them will probably be interested in some bytes at the beginning of the EEPROM, and then also let them issue their own reads for any other areas they need to look at (at *some* risk of duplication, but presumably much less).",
      "parentUuid": "7ecf2985_e13b0980",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "250ea7c5_8391392d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-13T16:59:42Z",
      "side": 1,
      "message": "\u003e each with a \"probe\n\nIn practice, the probe statement tends to conflict heavily with actually reading the eeprom, and might require significant reading to determine if the device in question is of that type (not all devices have a nice header in the first 8 bytes).  At a high level (at least in how I imagine this) I wouldn\u0027t expect a separate probe statement, I\u0027d expect more of a\n\nif (attemptToReadIPMIFru(){\n   return;\n}\nif (attemptToReadLinkedinFru()){\n   return;\n}\n\nType logic.  (obviously if maps/arrays and loops are more appropriate feel free to use them.)\n\nEach individual function might include some kind of probe mechanic to return early.\n\nThe only advantage of the probe setup you suggest is that we can tell the difference between an invalid fru that has a header for something known, so we could print something like \"Invalid Linkedin FRU\".  Maybe that\u0027s important?\n\n\n\u003e So to avoid that, we could introduce some little cache abstraction to store and regurgitate whatever bytes have already been read by an earlier matcher, perhaps as an offset:data map at some fixed granularity (blocks of 16 or 32 bytes or something, say).\n\nYeah, lets do this.  To simplify it, we could also just always read the eeprom linearly, and just track how far we\u0027ve read into it to make the cache easier to code.  So if a \"driver\" requests bytes 20-28, but the cache contains 0-8, we would implicitly read 9-28 into the cache for completeness.  That I think simplifies the need for an offset:data map, and makes the payload just a vector of read bytes.\n\nMy my 2 cents.",
      "parentUuid": "32ce2779_c003e84d",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b59a4301_86ef3731",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-02-13T16:59:42Z",
      "side": 1,
      "message": "There\u0027s already several efforts to restructure FRUDevice in review;  If you\u0027re interested in helping with the restructuring, I would definitely help review, and start with those to see what those people are trying to get out of a restructuring.\n\nI\u0027d love to entertain discussions about rust (I have some prototypes on my dev box as well) but we need to look at it holistically as a system, not in the context of RIIR, and definitely not in the context of adding linkedin FRU support.",
      "parentUuid": "67eeeef1_59102aa3",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "50b0904d_f8d736b1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-13T19:07:30Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b59a4301_86ef3731",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb87598c_995595e3",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-13T19:07:30Z",
      "side": 1,
      "message": "\u003e To simplify it, we could also just always read the eeprom linearly, and just track how far we\u0027ve read into it to make the cache easier to code.  So if a \"driver\" requests bytes 20-28, but the cache contains 0-8, we would implicitly read 9-28 into the cache for completeness.  That I think simplifies the need for an offset:data map, and makes the payload just a vector of read bytes.\n\nWouldn\u0027t that lead to reading in a lot of excess unneeded data in the Tyan case though?",
      "parentUuid": "250ea7c5_8391392d",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b26dd6da_cb343a23",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-14T22:07:45Z",
      "side": 1,
      "message": "\u003e In practice, the probe statement tends to conflict heavily with actually reading the eeprom, and might require significant reading to determine if the device in question is of that type (not all devices have a nice header in the first 8 bytes).  At a high level (at least in how I imagine this) I wouldn\u0027t expect a separate probe statement,\n\nIf the distinction you\u0027re drawing here is between\n\n (a) having one strictly boolean function for checking for the presence of a given format and another to then go read and parse that format\n\nand\n\n (b) having a single combined function to attempt a read/parse and possibly fail\n\nthen yes, (b) certainly seems like the preferable approach.  I didn\u0027t mean to imply that I was really aiming for (a), though I see how it might\u0027ve read that way (I was intending the \"probe\" terminology more in the sense that it\u0027s used in kernel drivers, i.e. \"try to set up a device of a particular type at a given address\").\n\n(If I\u0027ve misunderstood and there\u0027s some other distinction you\u0027re getting at though, please correct as needed.)",
      "parentUuid": "fb87598c_995595e3",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97bb2be3_711dfb59",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-02-14T22:07:45Z",
      "side": 1,
      "message": "\u003e There\u0027s already several efforts to restructure FRUDevice in review\n\nI see https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/47246 as an open review and a couple other small refactorings (https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/50921, https://gerrit.openbmc-project.xyz/c/openbmc/entity-manager/+/50894); are there others underway that I\u0027ve missed?",
      "parentUuid": "50b0904d_f8d736b1",
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "619d021a_d9074b6d",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 591,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "All of this li1902 specific stuff definitively deserves its own file.  Please keep only the reasonably generic things here.",
      "range": {
        "startLine": 591,
        "startChar": 0,
        "endLine": 591,
        "endChar": 51
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "e49bb044_7d09cacf",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 591,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "619d021a_d9074b6d",
      "range": {
        "startLine": 591,
        "startChar": 0,
        "endLine": 591,
        "endChar": 51
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "df1accd8_6285a4e3",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 595,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "In other places, we\u0027ve used dictionaries for this kind of thing, given that dictionaries are going to be needed anyway when this gets converted to dbus APIs.  I suspect we need to stick with that.",
      "range": {
        "startLine": 595,
        "startChar": 0,
        "endLine": 595,
        "endChar": 20
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fc4e0dc7_35acab80",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 595,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "df1accd8_6285a4e3",
      "range": {
        "startLine": 595,
        "startChar": 0,
        "endLine": 595,
        "endChar": 20
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dbf22ea5_f1528e0c",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 625,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Same thing as below.  This looks like something that should be relatively generic, and deduplicated with the existing fru code.",
      "range": {
        "startLine": 625,
        "startChar": 12,
        "endLine": 625,
        "endChar": 27
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "01375238_4c850569",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 635,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This seems like a really odd test to be doing ourselves.  Can you explain the rationale for it?  Generally in specs, fields are either defined as ascii or binary.  Detecting the \"asciness\" of fru fields is not 100%, and we should be explicitly declaring a field binary, or ascii when we read it out.",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 635,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8c5187e2_f890aac4",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 635,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "This is basically just an artifact of the lack of any formal spec for the format -- in the examples I\u0027ve got on hand I\u0027ve only seen ASCII text, but I don\u0027t know what \"rules\" (or lack thereof) there might be regarding encodings in general.  Given that the IPMI FRU format has provisions for specifying encodings per-field with the type/length byte I figured I\u0027d have it use ASCII where the data looked like ASCII and just pass it through as raw binary otherwise (though there\u0027s of course some risk of inaccuracy there if data that \"should\" be binary happens to look like ASCII).",
      "parentUuid": "01375238_4c850569",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 635,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a889b70_c84cab15",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 635,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-14T18:45:33Z",
      "side": 1,
      "message": "Could we just say that they\u0027re ascii, and if they\u0027re not, fail to push the key into the dictionary?  Having fields that dynamically change type dependent on the input gets a little error prone, and if we expect them all to be ascii, and the examples we have are ascii, lets just error on non-ascii until we have a use case.",
      "parentUuid": "8c5187e2_f890aac4",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 635,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7d367b6_995290fb",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 635,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-15T00:51:21Z",
      "side": 1,
      "message": "Sure, that sounds reasonable.",
      "parentUuid": "4a889b70_c84cab15",
      "range": {
        "startLine": 628,
        "startChar": 0,
        "endLine": 635,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f4f33f7_2aad4848",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 637,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This whole line is pretty confusing.  In the case where the string is too short, push back the str.size?  Can you please turn this into branches to make it more clear what\u0027s going on?",
      "range": {
        "startLine": 637,
        "startChar": 61,
        "endLine": 637,
        "endChar": 72
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "88492d25_f1323760",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 637,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This looks like we\u0027re trying to invent an IPMI FRU from this fru type?  I suspect we need to abstract out the \"set fru\" methods into something we can use directly.",
      "range": {
        "startLine": 637,
        "startChar": 19,
        "endLine": 637,
        "endChar": 60
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68bf099f_e646e15c",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 637,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "The `size \u003e\u003d 2` check is due to the IPMI FRU specification of type code 0b11, which says \"At least two bytes of data must be present when this type is used\", so it\u0027s just arranging a fallback to the 0b00 (binary/unspecified) type code if an ASCII string isn\u0027t long enough.  I can certainly expand/comment the code a bit to clarify though (if this code or anything analogous remains in future revisions, which perhaps it won\u0027t).",
      "parentUuid": "2f4f33f7_2aad4848",
      "range": {
        "startLine": 637,
        "startChar": 61,
        "endLine": 637,
        "endChar": 72
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38b586a9_1d9c3fba",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "I said this elsewhere, but I\u0027ll reiterate, we should not be inventing an IPMI FRU from a LI1920 FRU.  To do that is a little odd, and means that we probably need to abstract the \"set a field name\" method on the lower levels such that we can directly set the dictionary items, rather than converting one binary format to another, then converting it to dbus.  Please take another look at this, refactor and simplify.",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3592f610_b03f540f",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "\u003e ...we should not be inventing an IPMI FRU from a LI1920 FRU.  To do that is a little odd...\n\nEmphatically agreed, it\u0027s an awkward way of going about this -- but given that the FruDeviceManager interface\u0027s `GetRawFru` and `WriteFru` methods already expose the raw binary FRU data format via dbus, it seemed like the only option that wouldn\u0027t involve changing those APIs to use something more structured and then chasing down whatever users of those exist and updating them accordingly (which struck me as a much broader, more invasive change than seemed reasonable for this).\n\nThough perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\n(I\u0027m assuming we don\u0027t want to have those methods just accept \u0026 return arbitrary non-IPMI FRU data, since I think that would lead to alternate-format data leaking out into things like client-side ipmitool code and such, which doesn\u0027t seem likely to lead to anything good...)",
      "parentUuid": "38b586a9_1d9c3fba",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5516911a_300efe89",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-14T00:11:55Z",
      "side": 1,
      "message": "\u003e Though perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\nHmm, though thinking about it a bit more I guess this approach would probably also mean that `ipmitool fru print 0` wouldn\u0027t work to retrieve baseboard FRU info, which would be unfortunate (at least for the AHE-50DC, which uses this format for its baseboard FRU eeprom).",
      "parentUuid": "3592f610_b03f540f",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f2865abf_160fb2a0",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-14T18:45:33Z",
      "side": 1,
      "message": "\u003e FruDeviceManager interface\u0027s `GetRawFru` and `WriteFru` methods already expose the raw binary FRU data format via dbus\n\nGiven that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn\u0027t, that\u0027s going to break ipmitool (which I think is what you pointed out).\n\n\n\u003e Though perhaps we could have fru-device track which ones are of which type and just live with the constraint that those methods will only work on standard IPMI format FRUs...thoughts?\n\nOn its nose this sounds reasonable.  Lets look at what it does to the code and interfaces and go from there.",
      "parentUuid": "5516911a_300efe89",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2624b733_757a34f1",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-15T00:51:21Z",
      "side": 1,
      "message": "\u003e Given that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn\u0027t, that\u0027s going to break ipmitool (which I think is what you pointed out).\n\nFrom a quick glance at the users of those methods via OpenGrok, it looks like maybe they only really exist to facilitate IPMI \"Read FRU Data\" and \"Write FRU Data\" commands?  In which case if we\u0027re going to support non-IPMI FRU data (without just doing a format translation), I\u0027m not sure what we\u0027d use a corresponding raw-binary-data dbus API for, exactly...\n\nIn an ideal world I\u0027d still like to be able to use `ipmitool fru print` to retrieve baseboard FRU data on this system (hence the implementation path I took here), but I realize there\u0027s a bit of a fundamental mismatch between that operation and the non-IPMI-formatted FRU data I\u0027ve got.  It seems like if that\u0027s going to be made to work, the only way to support it is by putting a format translation *somewhere*.  Am I wishing for the impossible here?",
      "parentUuid": "f2865abf_160fb2a0",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bc1dbbbd_fd8f46f6",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 744,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-24T19:37:33Z",
      "side": 1,
      "message": "\u003e \u003e Given that those APIs are supposed to be exposing IPMI FRU payloads, it seems like we might need a new API for these?  I think the IPMI spec requires FRUs to follow the fru format, so if we had one that didn\u0027t, that\u0027s going to break ipmitool (which I think is what you pointed out).\n\u003e \n\u003e From a quick glance at the users of those methods via OpenGrok, it looks like maybe they only really exist to facilitate IPMI \"Read FRU Data\" and \"Write FRU Data\" commands?\n\nBasically.\n\n\u003e  In which case if we\u0027re going to support non-IPMI FRU data (without just doing a format translation), I\u0027m not sure what we\u0027d use a corresponding raw-binary-data dbus API for, exactly...\n\nSure, I guess that\u0027s a fair point if you don\u0027t intend on every reading/writing these in their \"raw\" form.\n\n\u003e \n\u003e In an ideal world I\u0027d still like to be able to use `ipmitool fru print` to retrieve baseboard FRU data on this system (hence the implementation path I took here), but I realize there\u0027s a bit of a fundamental mismatch between that operation and the non-IPMI-formatted FRU data I\u0027ve got.  It seems like if that\u0027s going to be made to work, the only way to support it is by putting a format translation *somewhere*.\n\n\nipmitool is open source and can accept patches, you could add this new fru format to it if you wanted, and not do any translation at any level.  Whether or not you do it as part of the normal IPMI fru commands is something we should probably discuss on a larger forum somewhere.\n\n\u003e  Am I wishing for the impossible here?\n\nIn terms of translation, a little.  From where I sit it seems to be complexity for lack of wanting to modify ipmitool to support this new fru format, which doesn\u0027t seem great to me.",
      "parentUuid": "2624b733_757a34f1",
      "range": {
        "startLine": 640,
        "startChar": 0,
        "endLine": 744,
        "endChar": 0
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be78c7ba_749bef35",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 745,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "nit, this would look better if you ordered the input params first, THEN the output param.",
      "range": {
        "startLine": 745,
        "startChar": 30,
        "endLine": 745,
        "endChar": 46
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5162863_c69ed9b6",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 745,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Can this be deduplicated with the other string reading functions?  It doesn\u0027t look that unique.",
      "range": {
        "startLine": 745,
        "startChar": 14,
        "endLine": 745,
        "endChar": 29
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6420801c_041cc666",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 745,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "be78c7ba_749bef35",
      "range": {
        "startLine": 745,
        "startChar": 30,
        "endLine": 745,
        "endChar": 46
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48dbaaa0_16ae8d00",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 747,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "We shouldn\u0027t need to clear a string before using it.",
      "range": {
        "startLine": 747,
        "startChar": 0,
        "endLine": 747,
        "endChar": 16
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ace45750_b7f767f0",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 747,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "48dbaaa0_16ae8d00",
      "range": {
        "startLine": 747,
        "startChar": 0,
        "endLine": 747,
        "endChar": 16
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "865a206c_87a6b9c0",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 767,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Considering this is essentially a single magic string, can we do this in one check against LI1902?  That would help to make this code more generic, similar to the tyan board.",
      "range": {
        "startLine": 767,
        "startChar": 4,
        "endLine": 767,
        "endChar": 43
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8c8ccf5b_d552b5aa",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 767,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "865a206c_87a6b9c0",
      "range": {
        "startLine": 767,
        "startChar": 4,
        "endLine": 767,
        "endChar": 43
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c335f60d_2a43af20",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 770,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This is basically easctly the same check being done here: \n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L616\n\nPlease come up with a generic mechanism for this, as I suspect this kind of thing is going to come up repeatedly from time to time.",
      "range": {
        "startLine": 767,
        "startChar": 0,
        "endLine": 770,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "aebfdbf7_748e742a",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 770,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "c335f60d_2a43af20",
      "range": {
        "startLine": 767,
        "startChar": 0,
        "endLine": 770,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfe5bb83_75b9d6ae",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 785,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "manufacturing dates almost certainly need converted to an epoch value.",
      "range": {
        "startLine": 785,
        "startChar": 0,
        "endLine": 785,
        "endChar": 54
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8f1041ca_facc418a",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 785,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Given that the approach of this patch was to convert to the IPMI format and that this field didn\u0027t seem to correspond perfectly to any of its fields I just dropped it.  It appears to be a MMDDYYYY string though; in a dictionary-based version as you suggested should that be parsed \u0026 re-formatted?",
      "parentUuid": "cfe5bb83_75b9d6ae",
      "range": {
        "startLine": 785,
        "startChar": 0,
        "endLine": 785,
        "endChar": 54
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c9cbc93e_57a69e6c",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 785,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-14T18:45:33Z",
      "side": 1,
      "message": "For some reason I thought IPMI FRUs had a manufacturing date that we turned into an EPOCH value..... Here\u0027s the code for it:\n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L350\n\nLooks like we just turn it into a string though, so I was mistaken.",
      "parentUuid": "8f1041ca_facc418a",
      "range": {
        "startLine": 785,
        "startChar": 0,
        "endLine": 785,
        "endChar": 54
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e05c92d5_f5a36286",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 793,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Should we be checking this first, as part of the \"magic\" checking so we can fail earlier in the case it doesn\u0027t match?",
      "range": {
        "startLine": 793,
        "startChar": 0,
        "endLine": 793,
        "endChar": 64
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8bc79005_8a6d8b3a",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 793,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "e05c92d5_f5a36286",
      "range": {
        "startLine": 793,
        "startChar": 0,
        "endLine": 793,
        "endChar": 64
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b11279a9_72187edd",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 806,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "init your variables please.  Should just be a matter of adding {} to the end.",
      "range": {
        "startLine": 806,
        "startChar": 0,
        "endLine": 806,
        "endChar": 26
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1701f677_2435f8f4",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 806,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b11279a9_72187edd",
      "range": {
        "startLine": 806,
        "startChar": 0,
        "endLine": 806,
        "endChar": 26
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "912e3c56_8a466777",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 807,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Same here.",
      "range": {
        "startLine": 807,
        "startChar": 0,
        "endLine": 807,
        "endChar": 45
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "47f42b31_e490c777",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 807,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "912e3c56_8a466777",
      "range": {
        "startLine": 807,
        "startChar": 0,
        "endLine": 807,
        "endChar": 45
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2323414_15855de9",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 818,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "This function can clearly fail, but doesn\u0027t really seem to be giving any indication in the API that it failed, instead returning a default constructed struct.  Please improve that with some status code returns such that the caller can differentiate failure types.",
      "range": {
        "startLine": 818,
        "startChar": 0,
        "endLine": 818,
        "endChar": 22
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f1d9755_55184327",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 818,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "This was just due to the fact that its only caller (`readFRUContents()`) does the same thing on error, so this allowed that call site to just be `return readLI19FRUContents()`.  I\u0027m not sure what `readFRUContents()` would do with a more specific error indicator other than print an error message, but that\u0027s already being done here, so I didn\u0027t see much point.",
      "parentUuid": "a2323414_15855de9",
      "range": {
        "startLine": 818,
        "startChar": 0,
        "endLine": 818,
        "endChar": 22
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37c6bc0d_d0c4382b",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 821,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "As written, this is duplicating the actual read operation of the first 8 bytes with findFRUHeader here:\n\nhttps://github.com/openbmc/entity-manager/blob/bd4075f74380271e58d01097cd10c6e1e2c3b92d/src/FruUtils.cpp#L595\n\nFor systems that don\u0027t have one of these devices installed, that\u0027s going to cause scanning performance problems.  As part of your refactoring effort asked for above, please fix that such that the first 8 bytes are only read once, similar to how the tyan board did it.",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 821,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "16faa718_b0260c7b",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 821,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "37c6bc0d_d0c4382b",
      "range": {
        "startLine": 810,
        "startChar": 0,
        "endLine": 821,
        "endChar": 5
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3545fc64_55645331",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 827,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "Please remove this.  Having Frus that AREN\u0027T LI1902 isn\u0027t an error, and shouldn\u0027t be filling up the logs.",
      "range": {
        "startLine": 827,
        "startChar": 12,
        "endLine": 827,
        "endChar": 74
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ee25d14e_92981333",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 827,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "This function should only be called as a fallback if findFRUHeader() fails, so this message should only ever be seen for a eeprom that\u0027s not recognized as standard IPMI, Tyan format, or LI1902 (and even then only if someone goes out of their way to set the `debug` flag).  Though given the amount of rewriting it looks like this patch is going to need this logic will probably all look fairly different anyway...",
      "parentUuid": "3545fc64_55645331",
      "range": {
        "startLine": 827,
        "startChar": 12,
        "endLine": 827,
        "endChar": 74
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d907a414_dc948bd8",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 827,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-14T18:45:33Z",
      "side": 1,
      "message": "\u003e This function should only be called as a fallback if findFRUHeader() fails, so this message should only ever be seen for a eeprom that\u0027s not recognized as standard IPMI, Tyan format, or LI1902 (and even then only if someone goes out of their way to set the `debug` flag).\n\nWhat you described happens on almost every system.  There are lots of i2c devices that look like eeproms that we ignore.\n\n\n\u003e  Though given the amount of rewriting it looks like this patch is going to need this logic will probably all look fairly different anyway...\n\n+1",
      "parentUuid": "ee25d14e_92981333",
      "range": {
        "startLine": 827,
        "startChar": 12,
        "endLine": 827,
        "endChar": 74
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "b7a0be33_25ae4e4a",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 827,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-15T00:51:21Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "d907a414_dc948bd8",
      "range": {
        "startLine": 827,
        "startChar": 12,
        "endLine": 827,
        "endChar": 74
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f8151a2_f6c44d1a",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 894,
      "author": {
        "id": 1000153
      },
      "writtenOn": "2022-01-13T18:20:54Z",
      "side": 1,
      "message": "There\u0027s already a precedence for doing this kind of thing in the findFruHeader method.  I\u0027d like to see this moved there such that we\u0027re keeping all the custom-board fru parsing logic in one place.  Alternatively, we could move the tyan stuff here if it looks cleaner, but I\u0027d really like one place to look for all the \"check for custom magic string\" functions.",
      "range": {
        "startLine": 894,
        "startChar": 15,
        "endLine": 894,
        "endChar": 34
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3bf1b170_8d546a8e",
        "filename": "src/FruUtils.cpp",
        "patchSetId": 4
      },
      "lineNbr": 894,
      "author": {
        "id": 1000733
      },
      "writtenOn": "2022-01-13T23:45:44Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0f8151a2_f6c44d1a",
      "range": {
        "startLine": 894,
        "startChar": 15,
        "endLine": 894,
        "endChar": 34
      },
      "revId": "14a35fba1deb2cd8a2a4412bb3d1c258855de689",
      "serverId": "adbd0a64-1f21-4d83-b585-671fe73cb6e4"
    }
  ]
}